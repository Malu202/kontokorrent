{"version":3,"file":"81b9bc796c7e43683b79.bundle.js","mappings":"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","sources":["webpack://kontokorrent/webpack/runtime/chunk loaded","webpack://kontokorrent/webpack/runtime/startup chunk dependencies","webpack://kontokorrent/./src/lib/AccountType.ts","webpack://kontokorrent/./src/api/postJson.ts","webpack://kontokorrent/./src/api/TokenRenewFailedException.ts","webpack://kontokorrent/./src/api/InteractionRequiredException.ts","webpack://kontokorrent/./src/api/ApiException.ts","webpack://kontokorrent/./src/environment.ts","webpack://kontokorrent/./src/api/NeueBezahlungFailedException.ts","webpack://kontokorrent/./src/api/BezahlungBearbeitenFailedException.ts","webpack://kontokorrent/./src/api/BezahlungLoeschenFailedException.ts","webpack://kontokorrent/./src/api/ApiClient.ts","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/state/State.ts","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/state/actions/BeschreibungVorschlagActionCreator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/lib/ausgleich/Score.ts","webpack://kontokorrent/./src/lib/ausgleich/balanceList.ts","webpack://kontokorrent/./src/lib/ausgleich/PersonenBeziehungScoreBewerter.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichsZahlung.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichStatus.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichNichtMoeglichError.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichService.ts","webpack://kontokorrent/./src/state/actions/KontokorrentSyncActionCreator.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/./src/lib/AccountInfoStore.ts","webpack://kontokorrent/./node_modules/core-js/internals/object-get-own-property-names.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim-forced.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim.js","webpack://kontokorrent/./node_modules/core-js/internals/whitespaces.js","webpack://kontokorrent/./node_modules/core-js/modules/es.string.trim.js","webpack://kontokorrent/webpack/bootstrap","webpack://kontokorrent/webpack/runtime/define property getters","webpack://kontokorrent/webpack/runtime/ensure chunk","webpack://kontokorrent/webpack/runtime/get javascript chunk filename","webpack://kontokorrent/webpack/runtime/get mini-css chunk filename","webpack://kontokorrent/webpack/runtime/global","webpack://kontokorrent/webpack/runtime/hasOwnProperty shorthand","webpack://kontokorrent/webpack/runtime/publicPath","webpack://kontokorrent/webpack/runtime/importScripts chunk loading","webpack://kontokorrent/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(820).then(next);\n};","export enum AccountType {\n    google = \"google\",\n    anonym = \"anonym\"\n};\n","export async function postJson(url: string, body: any, token?: string) {\n    let init: RequestInit = {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    };\n    if (token) {\n        init.headers = { ...init.headers, \"Authorization\": `Bearer ${token}` };\n    }\n    return await fetch(url, init);\n}","export class TokenRenewFailedException {\n    constructor(public readonly networkError: boolean) {\n\n    }\n}","export class InteractionRequiredException {\n\n}\n\n","\nexport class ApiException {\n}\n","let API_URL;\nif (__ENVIRONMENT == \"local\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pagesv2\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\n\nexport const environment = {\n    API_URL: API_URL\n};\n","\nexport class NeueBezahlungFailedException {\n}\n\n\n","\nexport class BezahlungBearbeitenFailedException {\n}\n","\nexport class BezahlungLoeschenFailedException {\n}\n","import { postJson } from \"./postJson\";\nimport { AccountType } from \"../lib/AccountType\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentInfo } from \"./KontokorrentInfo\";\nimport { NeuerKontokorrentRequest } from \"./NeuerKontokorrentRequest\";\nimport { TokenRenewFailedException } from \"./TokenRenewFailedException\";\nimport { InteractionRequiredException } from \"./InteractionRequiredException\";\nimport { ApiException } from \"./ApiException\";\nimport { Aktion } from \"./Aktion\";\nimport { environment } from \"../environment\";\nimport { NeueBezahlungRequest } from \"./NeueBezahlungRequest\";\nimport { NeueBezahlungFailedException } from \"./NeueBezahlungFailedException\";\nimport { BezahlungBearbeitenRequest } from \"./BezahlungBearbeitenRequest\";\nimport { BezahlungBearbeitenFailedException } from \"./BezahlungBearbeitenFailedException\";\nimport { BezahlungLoeschenFailedException } from \"./BezahlungLoeschenFailedException\";\n\nconst baseUrl = environment.API_URL;\n\nexport class ApiClient {\n\n    constructor(private accountInfoStore: AccountInfoStore) {\n\n    }\n\n    async neuerBenutzer(id: string, secret: string) {\n        try {\n            let res = await postJson(`${baseUrl}/api/v2/accounts`, { id, secret });\n            if (!res.ok) {\n                return { success: false };\n            }\n            return { success: true };\n        }\n        catch(err) {\n            return { success: false };\n        }\n    }\n\n    async getUserInfo() {\n        let res = await fetch(`${baseUrl}/api/v2/userinfo`, { headers: await this.getAuthHeader() });\n        return await res.json();\n    }\n\n    private async getAuthHeader() {\n        return { \"Authorization\": `Bearer ${await this.getAccessToken()}` };\n    }\n\n    async kontokorrentHinzufuegen(oeffentlicherName: string, einladungsCode: string) {\n        let params = \"\";\n        if (oeffentlicherName) {\n            params = `oeffentlicherName=${encodeURIComponent(oeffentlicherName)}`;\n        }\n        else {\n            params = `einladungsCode=${encodeURIComponent(einladungsCode)}`;\n        }\n        let headers = await this.getAuthHeader();\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents?${params}`, { method: \"PUT\", headers: headers });\n        if (res.status == 404) {\n            return null;\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n    async kontokorrentsAuflisten() {\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents`, { headers: await this.getAuthHeader() });\n        if (!res.ok) {\n            throw new ApiException();\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n\n    async neuerKontokorrent(request: NeuerKontokorrentRequest) {\n        let res = await postJson(`${baseUrl}/api/v2/kontokorrents`, request, await this.getAccessToken());\n        if (res.status == 422) {\n            return { success: false, exists: true };\n        }\n        else if (res.ok) {\n            return { success: true };\n        }\n        return { success: false };\n    }\n\n    async getAktionen(kontokorrentId: string, ab?: number) {\n        let query = ab ? `?ab=${ab}` : \"\";\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen${query}`, { headers: await this.getAuthHeader() });\n        if (res.status == 404) {\n            return {\n                success: false,\n                notfound: true\n            };\n        }\n        else if (res.ok) {\n            let aktionen: Aktion[] = await res.json();\n            return {\n                success: true,\n                aktionen: this.mapAktionen(aktionen)\n            }\n        }\n    }\n\n    private mapAktionen(aktionen : Aktion[]) : Aktion[] {\n        for (let a of aktionen) {\n            if (a.bezahlung) {\n                a.bezahlung.zeitpunkt = new Date(a.bezahlung.zeitpunkt);\n            }\n        }\n        return aktionen;\n    }\n\n    async neueBezahlung(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.hinzufuegenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new NeueBezahlungFailedException();\n    }\n\n    async bezahlungLoeschen(kontokorrentId: string, bezahlungId:string) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.loeschenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify({id:bezahlungId})\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungLoeschenFailedException();\n    }\n\n    async bezahlungBearbeiten(kontokorrentId: string, request: BezahlungBearbeitenRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.bearbeitenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungBearbeitenFailedException();\n    }\n\n\n    private async getAccessToken() {\n        let info = await this.accountInfoStore.get();\n        if (null == info) {\n            throw new Error(\"Keine Account Information gespeichert.\");\n        }\n        if (info.type == AccountType.anonym) {\n            let tokenInfo = await this.accountInfoStore.getAccessToken(\"anonymous\");\n            if (null != tokenInfo) {\n                let { token, expires } = JSON.parse(tokenInfo.value);\n                if (token && expires && expires >= +new Date()) {\n                    return token;\n                }\n            }\n            let tokenResponse;\n            try {\n                let res = await postJson(`${baseUrl}/api/v2/token`, { id: info.id, secret: info.secret });\n                if (!res.ok) {\n                    throw new TokenRenewFailedException(false);\n                }\n                tokenResponse = await res.json();\n            }\n            catch(err) {\n                throw new TokenRenewFailedException(true);\n            }\n            await this.accountInfoStore.updateAccessTokenIfNewer(\"anonymous\", JSON.stringify(tokenResponse), tokenInfo?.timestamp);\n            return tokenResponse.token;\n        }\n        else if (info.type == AccountType.google) {\n            throw new InteractionRequiredException();\n            // let flow = new OAuth2PopupFlow({\n            //     authorizationUri: \"https://accounts.google.com/o/oauth2/v2/auth/.well-known/openid-configuration\",\n            //     clientId: \"82890837151-n0e81vsn3ns2qn1ksh7bdohmnlau468k.apps.googleusercontent.com\",\n            //     redirectUri: \"http://localhost:4200\",\n            //     scope: \"openid\",\n            //     responseType: \"id_token\",\n            //     additionalAuthorizationParameters: { \"login_hint\": info.id },\n            //     accessTokenStorageKey: \"access_token_google\"\n            // });\n            // return await flow.token();\n        }\n        else {\n            throw new Error(`Account Typ ${info.type} unbekannt`);\n        }\n    }\n}","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\nimport { BearbeitungsStatus } from \"./BearbeitungsStatus\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        let mapped = aktionen\n            .map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            });\n        return await this.withInitialized(db => {\n            const unwrapped = unwrap(<IDBPDatabase>db);\n            return new Promise((resolve, reject) => {\n                const tx = unwrapped.transaction(AktionenStore, \"readwrite\");\n                tx.onerror = err => {\n                    console.error(\"addAktionen failed\", err, tx.error);\n                    reject(tx.error);\n                };\n                tx.oncomplete = () => {\n                    resolve();\n                }\n                for (let a of mapped) {\n                    let request = tx.objectStore(AktionenStore).add(a);\n                    request.onerror = ev => {\n                        if (request.error.name == \"ConstraintError\") {\n                            console.log(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} bereits gespeichert.`, ev, request.error);\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        } else {\n                            console.error(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} konnte nicht gespeichert werden.`, ev, request.error);\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return (await db.getAll(NeueBezahlungenStore));\n        });\n    }\n\n    async getBezahlungAktion(kontokorrentId: string, bezahlungId: string): Promise<AktionDbModel> {\n        return await this.withInitialized(async db => {\n            var aktionen = db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            return (await aktionen).find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n        });\n    }\n\n    async getBearbeitungsStatus(kontokorrentId: string, bezahlungId: string): Promise<{ aktion: AktionDbModel, status: BearbeitungsStatus }> {\n        return await this.withInitialized(async db => {\n            let aktionen: AktionDbModel[] = await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            let aktion = aktionen.find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n            if (!aktion) {\n                let neueBezahlungen: NeueBezahlungDbModel[] = await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n                let neueBezahlung = neueBezahlungen.find(a => a.id == bezahlungId);\n                if (neueBezahlung) {\n                    return { aktion: null, status: BearbeitungsStatus.Zwischengespeichert };\n                }\n                return { aktion: null, status: BearbeitungsStatus.NichtGefunden };\n            }\n            let bearbeitendeAktion = aktionen.find(a => a.bearbeiteteBezahlungId == bezahlungId);\n            if (null != bearbeitendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Bearbeitet };\n            }\n            let loeschendeAktion = aktionen.find(a => a.geloeschteBezahlungId == bezahlungId);\n            if (null != loeschendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Geloescht };\n            }\n            return { aktion: aktion, status: BearbeitungsStatus.Bearbeitbar };\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","import { AccountInfo } from \"../lib/AccountInfo\";\nimport { KontokorrentAusgleich } from \"../lib/ausgleich/KontokorrentAusgleich\";\nimport { BearbeitungsStatus } from \"../lib/BearbeitungsStatus\";\n\nexport interface AccountState {\n    accountCreated: boolean,\n    accountCreating: boolean,\n    accountCreationFailed: boolean\n    loginExpired: boolean;\n    accountInfo: AccountInfo\n}\n\nexport interface KontokorrentsState {\n    kontokorrents: { [id: string]: KontokorrentState };\n    hinzufuegen: boolean;\n    listeLaden: boolean;\n    hinzufuegenFailed: {\n        kontokorrentNotFound: boolean\n    }\n    creating: boolean;\n    creationFailed: { exists: boolean };\n    activeKontokorrentId: string;\n    nichtGefunden: {\n        oeffentlicherName: string\n    }\n}\n\nexport interface Person {\n    name: string;\n    id: string;\n    balance: number;\n}\n\nexport enum BezahlungStatus {\n    Zwischengespeichert = \"zwischengespeichert\",\n    Speichern = \"speichern\",\n    Gespeichert = \"gespeichert\"\n}\n\nexport interface Bezahlung {\n    id: string;\n    zeitpunkt: Date;\n    bezahlendePersonId: string;\n    empfaengerIds: string[];\n    wert: number;\n    beschreibung: string;\n    status: BezahlungStatus\n}\n\nexport const enum RequestStatus {\n    InProgress,\n    Success,\n    Failed\n}\n\nexport interface AngezeigteBezahlungState {\n    bearbeitungsStatus: BearbeitungsStatus;\n    updateStatus?: RequestStatus;\n    deleteStatus?: RequestStatus;\n}\n\nexport interface KontokorrentState {\n    id: string;\n    name: string;\n    oeffentlicherName: string;\n    personen: Person[];\n    bezahlungen: Bezahlung[];\n    synchronisieren: boolean;\n    bezahlungAnlegen: RequestStatus;\n    angezeigteBezahlung: { [id: string]: AngezeigteBezahlungState }\n    ausgleichBerechnen: boolean;\n    ausgleich: KontokorrentAusgleich;\n}\n\nexport interface BeschreibungVorschlagState {\n    kontokorrentId: string;\n    vorschlaege: string[];\n}\n\nexport interface State {\n    account: AccountState\n    kontokorrents: KontokorrentsState;\n    beschreibungVorschlaege: BeschreibungVorschlagState;\n}\n","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { Store } from \"../lib/Store\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { ActionNames } from \"./ActionNames\";\nimport { Action } from \"../lib/Action\";\nimport { groupBy } from \"../../utils/groupBy\";\n\nexport class BeschreibungsVorschlaege implements Action {\n    readonly type = ActionNames.BeschreibungsVorschlaege;\n    constructor(public kontokorrentId: string, public vorschlaege: string[]) {\n\n    }\n}\n\nexport type BeschreibungVorschlagActions =\n    | BeschreibungsVorschlaege;\n\nexport class BeschreibungVorschlagActionCreator {\n    private beschreibungenCache: { kontokorrentId: string, beschreibungen: { search: string, result: string, occurence: number }[] };\n    constructor(private db: KontokorrentDatabase, private store: Store) {\n        this.resetCache();\n    }\n\n\n    private formatSearchString(s: string) {\n        return s.toLowerCase().replace(/\\s|-/g, \"\");\n    }\n\n    private sameChars(s: string, d: string) {\n        let i;\n        for (i = 0; i < Math.min(s.length, d.length); i++) {\n            if (s[i] != d[i]) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    resetCache() {\n        this.beschreibungenCache = { kontokorrentId: null, beschreibungen: [] };\n    }\n\n    async getVorschlaege(kontokorrentId: string, eingabe: string) {\n        if (this.beschreibungenCache.kontokorrentId != kontokorrentId) {\n            let aktionen = await this.db.getAktionen(kontokorrentId);\n            let beschreibungen = aktionen.filter(a => null != a.bezahlung?.beschreibung).map(a => {\n                return { search: this.formatSearchString(a.bezahlung.beschreibung), result: a.bezahlung.beschreibung.trim() }\n            });\n            this.beschreibungenCache.kontokorrentId = kontokorrentId;\n            let map = groupBy(beschreibungen, \"search\");\n            this.beschreibungenCache.beschreibungen = Array.from(map.entries()).map(([search, r]) => {\n\n                return {\n                    search,\n                    result: r[0].result,\n                    occurence: r.length\n                };\n            }).sort((a, b) => b.occurence - a.occurence);\n        }\n        if (eingabe) {\n            let formatted = this.formatSearchString(eingabe);\n            let vorschlaege = this.beschreibungenCache.beschreibungen\n                .filter(({ search }) => search.indexOf(formatted) > -1)\n                .map(({ search, result }) => {\n                    return { result, score: this.sameChars(formatted, search) }\n                }).sort((a, b) => b.score - a.score);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege.map(b => b.result)));\n        }\n        else {\n            let vorschlaege = this.beschreibungenCache.beschreibungen.slice(0, 10).map(b => b.result);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege));\n        }\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let sorted = aktionen.map(v => v.laufendeNummer).sort((a, b) => a - b);\n        let i: number;\n        for (i = 0; i < sorted.length - 1; i++) {\n            if (sorted[i] + 1 !== sorted[i + 1]) {\n                break;\n            }\n        }\n        return sorted[i];\n    }\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\ntype Bezahlung = { empfaengerIds: string[], bezahlendePersonId: string, wert: number };\n\ninterface KontokorrentBalanceRequest {\n    kontokorrentId: string;\n    zwischengespeicherte: boolean;\n    bisLaufendeNummer: null | number;\n}\n\ninterface KontokorrentBalanceResult {\n    bezahlungen: Bezahlung[];\n    balance: KontokorrentBalance;\n}\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    private erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async getBalance(request: KontokorrentBalanceRequest): Promise<KontokorrentBalanceResult> {\n        let aktionen = await this.db.getAktionen(request.kontokorrentId);\n        if (request.bisLaufendeNummer) {\n            aktionen = aktionen.filter(a => a.laufendeNummer <= request.bisLaufendeNummer);\n        }\n        let gespeicherte: Bezahlung[] = filterBezahlungen(aktionen);\n        let bezahlungen: Bezahlung[];\n        let zwischengespeicherte: Bezahlung[] = await this.db.getZwischengespeicherteBezahlungenForKontokorrent(request.kontokorrentId);\n        if (request.zwischengespeicherte) {\n            bezahlungen = [...zwischengespeicherte, ...gespeicherte];\n        } else {\n            bezahlungen = gespeicherte;\n        }\n        let kk = await this.db.getKontokorrent(request.kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return {\n            bezahlungen: bezahlungen,\n            balance: balance\n        };\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        return (await this.getBalance({\n            kontokorrentId: kontokorrentId,\n            zwischengespeicherte: true,\n            bisLaufendeNummer: null\n        })).balance;\n    }\n}","\nexport class Score {\n    constructor(public personA: string, public personB: string, public value: number) {\n    }\n    public Is(a: string, b: string): boolean {\n        return (this.personA == a && this.personB == b) || (this.personA == b && this.personB == a);\n    }\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\n\n\nexport function balanceList(balance: KontokorrentBalance) {\n    return Object.entries(balance).map(([k, v]) => {\n        return {\n            personId: k,\n            wert: v\n        };\n    });\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\nimport { ZahlungsBewerter } from \"./ZahlungsBewerter\";\nimport { GeforderteZahlung } from \"./GeforderteZahlung\";\nimport { AusgleichsZahlung } from \"./AusgleichsZahlung\";\nimport { Score } from \"./Score\";\nimport { balanceList } from \"./balanceList\";\n\nfunction getMax(a: number[]) {\n    let max = a[0];\n    for (let v of a) {\n        if (v > max) {\n            max = v;\n        }\n    }\n    return max;\n}\n\nexport class PersonenBeziehungScoreBewerter implements ZahlungsBewerter {\n    private scores: Score[];\n\n    constructor(balance: KontokorrentBalance, bezahlungen: {\n        empfaengerIds: string[];\n        bezahlendePersonId: string;\n    }[], bevorzugteZahlungen: GeforderteZahlung[]) {\n        this.scores = this.getScores(balance, bezahlungen);\n        var max = getMax(this.scores.map(v => v.value));\n        max += 1.0;\n        for (let bevorzugteZahlung of bevorzugteZahlungen) {\n            this.scores.find(v => v.Is(bevorzugteZahlung.bezahlendePersonId, bevorzugteZahlung.empfaengerPersonId)).value = max;\n        }\n    }\n\n    private compare(x: AusgleichsZahlung, y: AusgleichsZahlung): number {\n        if (null == x || null == y) {\n            return -1;\n        }\n        var xScore = this.scores.find(v => v.Is(x.bezahlendePersonId, x.empfaengerPersonId)).value;\n        var yScore = this.scores.find(v => v.Is(y.bezahlendePersonId, y.empfaengerPersonId)).value;\n        if (Math.abs(xScore - yScore) < Number.EPSILON) {\n            return 0;\n        }\n        else if (xScore < yScore) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n\n    findeBesteZahlung(a: AusgleichsZahlung[]): AusgleichsZahlung {\n        return a.sort((a, b) => this.compare(b, a))[0];\n    }\n\n    private getScores(balance: KontokorrentBalance, bezahlungen: {\n        empfaengerIds: string[];\n        bezahlendePersonId: string;\n    }[]) {\n        let scores: Score[] = [];\n        let list = balanceList(balance);\n        for (let pA of list) {\n            for (let pB of list) {\n                if (pB.personId != pA.personId) {\n                    if (!scores.some(s => s.Is(pA.personId, pB.personId))) {\n                        scores.push(new Score(pA.personId, pB.personId, 0));\n                    }\n                }\n            }\n        }\n\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                if (b.bezahlendePersonId != e) {\n                    var score = scores.find(s => s.Is(b.bezahlendePersonId, e));\n                    score.value += 1.0 / b.empfaengerIds.length;\n                }\n            }\n        }\n        return scores;\n    }\n}\n","\nexport class AusgleichsZahlung {\n    constructor(public bezahlendePersonId: string,\n        public empfaengerPersonId: string,\n        public wert: number) {\n    }\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\nimport { AusgleichsZahlung } from \"./AusgleichsZahlung\";\nimport { ZahlungsBewerter } from \"./ZahlungsBewerter\";\nimport { GeforderteZahlung } from \"./GeforderteZahlung\";\nimport { KontokorrentAusgleich } from \"./KontokorrentAusgleich\";\nimport { balanceList } from \"./balanceList\";\n\nfunction isCloseTo(a: number, b: number, epsilon?: number): boolean {\n    return Math.abs(a - b) < (epsilon || Number.EPSILON);\n}\n\n\nexport class AusgleichStatus {\n    private angewendeteZahlungen: AusgleichsZahlung[];\n\n    constructor(private balance: KontokorrentBalance, private zahlungsBewerter: ZahlungsBewerter) {\n        this.angewendeteZahlungen = [];\n    }\n\n    private anwenden(ausgleichsZahlungen: AusgleichsZahlung[]) {\n        let b = { ...this.balance };\n        for (let a of ausgleichsZahlungen) {\n            b[a.bezahlendePersonId] -= a.wert;\n            b[a.empfaengerPersonId] += a.wert;\n        }\n        this.balance = b;\n        this.angewendeteZahlungen = [...this.angewendeteZahlungen, ...ausgleichsZahlungen];\n    }\n\n    mussZahlungenAnwenden(mussZahlungen: GeforderteZahlung[]) {\n        let zahlungen = mussZahlungen.map(z => {\n            let bezahlenderStatus = this.balance[z.bezahlendePersonId];\n            return new AusgleichsZahlung(z.bezahlendePersonId, z.empfaengerPersonId, bezahlenderStatus);\n        });\n        this.anwenden(zahlungen);\n    }\n\n    gleicheAufloesen() {\n        let list = balanceList(this.balance);\n        let zahlungen = list.filter(p => p.wert > 0).map(bezahlender => {\n            let empfaenger = list.find(p2 => p2.personId != bezahlender.personId && isCloseTo(0, p2.wert + bezahlender.wert));\n            if (empfaenger) {\n                return new AusgleichsZahlung(bezahlender.personId, empfaenger.personId, bezahlender.wert);\n            }\n            return null;\n        }).filter(z => z != null);\n        this.anwenden(zahlungen);\n    }\n\n    gleichheitErzeugen() {\n        let list = balanceList(this.balance);\n        let moeglicheGleichheitsZahlungen = list.filter(p => p.wert > 0).map(bezahlender => {\n            let empfaengerKandidaten = list.filter(empf => -empf.wert > bezahlender.wert);\n            for (let empfaengerKandidat of empfaengerKandidaten) {\n                let ausgleichMoeglich = list.some(bezahlender2 => bezahlender.personId != bezahlender2.personId\n                    && bezahlender2.wert > 0\n                    && isCloseTo(empfaengerKandidat.wert + bezahlender.wert, -bezahlender2.wert));\n                if (ausgleichMoeglich) {\n                    return new AusgleichsZahlung(bezahlender.personId, empfaengerKandidat.personId, bezahlender.wert);\n                }\n            }\n            return null;\n        }).filter(z => z != null);\n        if (moeglicheGleichheitsZahlungen.length > 0) {\n            let best = this.zahlungsBewerter.findeBesteZahlung(moeglicheGleichheitsZahlungen);\n            this.anwenden([best]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    istAufgeloest(): boolean {\n        return !Object.values(this.balance).some(s => !isCloseTo(s, 0, 0.05));\n    }\n\n    getAusgleich(): KontokorrentAusgleich {\n        return {\n            ausgleichZahlungen: this.angewendeteZahlungen\n        };\n    }\n\n    private flattenAusgleichZahlungen(z: AusgleichsZahlung[][]) {\n        return z.reduce((a, b) => a.concat(b), []);\n    }\n\n\n    moeglicheZahlung() {\n        let list = balanceList(this.balance);\n        let einfacheZahlungKandidaten = list.filter(b => b.wert > 0)\n            .map(bezahlender => {\n                return list.filter(empf => empf.personId != bezahlender.personId && -empf.wert > bezahlender.wert)\n                    .map(empfaenger => new AusgleichsZahlung(bezahlender.personId, empfaenger.personId, bezahlender.wert));\n            });\n\n        let einfacheZahlung = this.zahlungsBewerter.findeBesteZahlung(this.flattenAusgleichZahlungen(einfacheZahlungKandidaten));\n        if (null != einfacheZahlung) {\n            this.anwenden([einfacheZahlung]);\n            return;\n        }\n        let teilzahlungKandidaten = list.filter(b => b.wert > 0)\n            .map(bezahlender => {\n                return list.filter(empf => empf.personId != bezahlender.personId && empf.wert < 0)\n                    .map(empfaenger => new AusgleichsZahlung(bezahlender.personId, empfaenger.personId, Math.abs(empfaenger.wert)));\n            });\n        let teilzahlung = this.zahlungsBewerter.findeBesteZahlung(this.flattenAusgleichZahlungen(teilzahlungKandidaten));\n        if (null != teilzahlung) {\n            this.anwenden([teilzahlung]);\n        }\n    }\n}\n","\nexport class AusgleichNichtMoeglichError {\n}\n","import { BalanceCalculator } from \"../BalanceCalculator\";\nimport { KontokorrentDatabase } from \"../KontokorrentDatabase\";\nimport { PersonenBeziehungScoreBewerter } from \"./PersonenBeziehungScoreBewerter\";\nimport { AusgleichRequest } from \"./AusgleichRequest\";\nimport { KontokorrentAusgleich } from \"./KontokorrentAusgleich\";\nimport { AusgleichStatus } from \"./AusgleichStatus\";\nimport { AusgleichNichtMoeglichError } from \"./AusgleichNichtMoeglichError\";\n\nexport class AusgleichService {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    public async getAusgleich(request: AusgleichRequest): Promise<KontokorrentAusgleich> {\n        let calc = new BalanceCalculator(this.db);\n        let balance = await calc.getBalance({\n            kontokorrentId: request.kontokorrentId,\n            zwischengespeicherte: false,\n            bisLaufendeNummer: request.bisLaufendeNummer,\n        });\n        let ausgleichStatus = new AusgleichStatus(balance.balance, new PersonenBeziehungScoreBewerter(balance.balance, balance.bezahlungen, request.ausgleichOptions.geforderteZahlungen));\n        ausgleichStatus.mussZahlungenAnwenden(request.ausgleichOptions.mussZahlungen);\n        for (let i = 0; i < 1000; i++) {\n            if (ausgleichStatus.istAufgeloest()) {\n                return ausgleichStatus.getAusgleich();\n            }\n            ausgleichStatus.gleicheAufloesen();\n            if (!ausgleichStatus.istAufgeloest()) {\n                if (!ausgleichStatus.gleichheitErzeugen()) {\n                    ausgleichStatus.moeglicheZahlung();\n                }\n            }\n        }\n        throw new AusgleichNichtMoeglichError();\n    }\n}\n","import { Store } from \"../lib/Store\";\nimport { ApiClient } from \"../../api/ApiClient\";\nimport { Action } from \"../lib/Action\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { Bezahlung, BezahlungStatus } from \"../State\";\nimport { filterBezahlungen } from \"../../lib/filterBezahlungen\";\nimport { ActionNames } from \"./ActionNames\";\nimport { KontokorrentSynchronizer } from \"../../lib/KontokorrentSynchronizer\";\nimport { BalanceCalculator } from \"../../lib/BalanceCalculator\";\nimport { KontokorrentBalance } from \"../../lib/KontokorrentBalance\";\nimport { GeforderteZahlung } from \"../../lib/ausgleich/GeforderteZahlung\";\nimport { AusgleichOptions } from \"../../lib/ausgleich/AusgleichOptions\";\nimport { AusgleichService } from \"../../lib/ausgleich/AusgleichService\";\nimport { KontokorrentAusgleich } from \"../../lib/ausgleich/KontokorrentAusgleich\";\n\nexport class KontokorrentGeoeffnet implements Action {\n    readonly type = ActionNames.KontokorrentGeoeffnet;\n    constructor(public id: string) {\n\n    }\n}\n\nexport class KontokorrentBezahlungen implements Action {\n    readonly type = ActionNames.KontokorrentBezahlungen;\n    constructor(public kontokorrentId: string, public bezahlungen: Bezahlung[]) {\n\n    }\n}\n\nexport class KontokorrentSynchronisieren implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisieren;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentSynchronisiert implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisiert;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentBalanceAktualisiert implements Action {\n    readonly type = ActionNames.KontokorrentBalanceAktualisiert;\n    constructor(public kontokorrentId: string, public balance: KontokorrentBalance) {\n\n    }\n}\n\nexport class KontokorrentNichtGefunden implements Action {\n    readonly type = ActionNames.KontokorrentNichtGefunden;\n    constructor(public oeffentlicherName: string) {\n\n    }\n}\n\nexport class KontokorrentOeffnen implements Action {\n    readonly type = ActionNames.KontokorrentOeffnen;\n    constructor(public oeffentlicherName: string) {\n\n    }\n}\n\nexport class AusgleichBerechnen implements Action {\n    readonly type = ActionNames.AusgleichBerechnen;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class AusgleichBerechnet implements Action {\n    readonly type = ActionNames.AusgleichBerechnet;\n    constructor(public kontokorrentId: string, public ausgleich: KontokorrentAusgleich) {\n\n    }\n}\n\nexport type KontokorrentSyncActions =\n    | KontokorrentGeoeffnet\n    | KontokorrentBezahlungen\n    | KontokorrentSynchronisieren\n    | KontokorrentSynchronisiert\n    | KontokorrentBalanceAktualisiert\n    | KontokorrentNichtGefunden\n    | KontokorrentOeffnen\n    | AusgleichBerechnen\n    | AusgleichBerechnet;\n\nexport class KontokorrentSyncActionCreator {\n\n    constructor(private store: Store,\n        private apiClient: ApiClient,\n        private db: KontokorrentDatabase) {\n\n    }\n    private async refreshBezahlungen(id: string) {\n        let aktionen = filterBezahlungen(await this.db.getAktionen(id)).map(b => {\n            return {\n                ...b,\n                status: BezahlungStatus.Gespeichert\n            };\n        });\n        let zwischengespeicherte = (await this.db.getZwischengespeicherteBezahlungenForKontokorrent(id)).map(b => {\n            let x: Bezahlung = {\n                status: BezahlungStatus.Zwischengespeichert,\n                beschreibung: b.beschreibung,\n                bezahlendePersonId: b.bezahlendePersonId,\n                empfaengerIds: b.empfaengerIds,\n                id: b.id,\n                wert: b.wert,\n                zeitpunkt: b.zeitpunkt\n            };\n            return x;\n        }).filter(b => !aktionen.some(a => a.id == b.id));\n        this.store.dispatch(new KontokorrentBezahlungen(id, [...aktionen, ...zwischengespeicherte]));\n    }\n\n    private async calculateBalance(id: string) {\n        let balance = await (new BalanceCalculator(this.db).calculateBalance(id));;\n        this.store.dispatch(new KontokorrentBalanceAktualisiert(id, balance));\n    }\n\n    private async refreshKontokorrent(id: string) {\n        await Promise.all([this.refreshBezahlungen(id), this.calculateBalance(id)]);\n    }\n\n    private async kontokorrentSynchronisieren(id: string) {\n        this.store.dispatch(new KontokorrentSynchronisieren(id));\n        let laufendeNummer = await (new KontokorrentSynchronizer(this.db).getLaufendeNummer(id));\n        let res = await this.apiClient.getAktionen(id, laufendeNummer);\n        if (res.success) {\n            await this.db.addAktionen(id, res.aktionen);\n            if (res.aktionen.length > 0) {\n                await this.refreshKontokorrent(id);\n            }\n        }\n        this.store.dispatch(new KontokorrentSynchronisiert(id));\n    }\n\n\n\n    async kontokorrentOeffnen(oeffentlicherName: string) {\n        this.store.dispatch(new KontokorrentOeffnen(oeffentlicherName));\n        let kk = await this.db.getPerOeffentlichName(oeffentlicherName);\n        if (null != kk) {\n            this.store.dispatch(new KontokorrentGeoeffnet(kk.id));\n            await Promise.all([this.db.setZuletztGesehenerKontokorrentId(kk.id), this.refreshKontokorrent(kk.id)]);\n            await this.kontokorrentSynchronisieren(kk.id);\n        } else {\n            this.store.dispatch(new KontokorrentNichtGefunden(oeffentlicherName));\n        }\n    }\n\n    async ausgleichRechnen(oeffentlicherName: string, ausgleichOptions: AusgleichOptions) {\n        let kk = await this.db.getPerOeffentlichName(oeffentlicherName);\n        if (null != kk) {\n            this.store.dispatch(new AusgleichBerechnen(kk.id));\n            await this.kontokorrentSynchronisieren(kk.id);\n            let ausgleich = await (new AusgleichService(this.db).getAusgleich({\n                ausgleichOptions: ausgleichOptions,\n                bisLaufendeNummer: null,\n                kontokorrentId: kk.id\n            }));\n            this.store.dispatch(new AusgleichBerechnet(kk.id, ausgleich));\n        } else {\n            this.store.dispatch(new KontokorrentNichtGefunden(oeffentlicherName));\n        }\n    }\n}","import { ApiClient } from \"../api/ApiClient\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { AusgleichOptions } from \"../lib/ausgleich/AusgleichOptions\";\nimport { GeforderteZahlung } from \"../lib/ausgleich/GeforderteZahlung\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { BeschreibungVorschlagActionCreator } from \"../state/actions/BeschreibungVorschlagActionCreator\";\nimport { KontokorrentSyncActionCreator } from \"../state/actions/KontokorrentSyncActionCreator\";\nimport { Action } from \"../state/lib/Action\";\n\nlet storeAdapter = {\n    dispatch(action: Action): void {\n        self.postMessage({ type: \"statedispatch\", msg: action });\n    }\n}\n\nexport const enum WorkerMessageType {\n    KontokorrentOeffnen,\n    GetBeschreibungVorschlaege,\n    ResetBeschreibungenCache,\n    AusgleichRechnen\n}\n\nexport interface KontokorrentOeffnenMessage {\n    type: WorkerMessageType.KontokorrentOeffnen;\n    oeffentlicherName: string;\n}\n\nexport interface GetBeschreibungVorschlaegeMessage {\n    type: WorkerMessageType.GetBeschreibungVorschlaege;\n    kontokorrentId: string;\n    eingabe: string;\n}\nexport interface ResetBeschreibungenCacheMessage {\n    type: WorkerMessageType.ResetBeschreibungenCache;\n}\nexport interface AusgleichRechnenMessage {\n    type: WorkerMessageType.AusgleichRechnen;\n    oeffentlicherName: string;\n    ausgleichOptions: AusgleichOptions;\n}\n\ntype WorkerMessage = KontokorrentOeffnenMessage\n    | GetBeschreibungVorschlaegeMessage\n    | ResetBeschreibungenCacheMessage\n    | AusgleichRechnenMessage;\n\nconst db = new KontokorrentDatabase();\nconst accountInfoStore = new AccountInfoStore(db);\nconst apiClient = new ApiClient(accountInfoStore);\nconst beschreibungVorschlagActionCreator = new BeschreibungVorschlagActionCreator(db, storeAdapter);\nconst kontokorrentSyncActionCreator = new KontokorrentSyncActionCreator(storeAdapter, apiClient, db);\n\nasync function process(msg: WorkerMessage) {\n    switch (msg.type) {\n        case WorkerMessageType.KontokorrentOeffnen:\n            await kontokorrentSyncActionCreator.kontokorrentOeffnen(msg.oeffentlicherName);\n            break;\n        case WorkerMessageType.GetBeschreibungVorschlaege:\n            await beschreibungVorschlagActionCreator.getVorschlaege(msg.kontokorrentId, msg.eingabe);\n            break;\n        case WorkerMessageType.ResetBeschreibungenCache:\n            beschreibungVorschlagActionCreator.resetCache();\n            break;\n        case WorkerMessageType.AusgleichRechnen:\n            await kontokorrentSyncActionCreator.ausgleichRechnen(msg.oeffentlicherName, msg.ausgleichOptions);\n            break;\n    }\n}\n\nself.addEventListener(\"message\", e => {\n    let msg: WorkerMessage = e.data;\n    process(msg).catch(err => console.error(err));\n});","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","import { AccountInfo } from \"./AccountInfo\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class AccountInfoStore {\n    constructor(private db: KontokorrentDatabase) {\n\n    }\n\n    async set(accountInfo: AccountInfo): Promise<void> {\n        await this.db.setAccountInfo(accountInfo);\n    }\n    async get(): Promise<AccountInfo> {\n        return await this.db.getAccountInfo();\n    }\n    async clear(): Promise<void> {\n        await this.db.clearAccountInfo();\n    }\n\n    async getAccessToken(tokenType: \"google\" | \"anonymous\"): Promise<{ timestamp: number, value: string }> {\n        return await this.db.getAccessToken(tokenType);\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number) {\n        return await this.db.updateAccessTokenIfNewer(tokenType, value, lastTimeStamp);\n    }\n}\n\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","var fails = require('../internals/fails');\nvar whitespaces = require('../internals/whitespaces');\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","'use strict';\nvar $ = require('../internals/export');\nvar $trim = require('../internals/string-trim').trim;\nvar forcedStringTrimMethod = require('../internals/string-trim-forced');\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [820], function() { return __webpack_require__(3483); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + \"0cdd927a1d4532914d47\" + \".bundle.js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t81: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkontokorrent\"] = self[\"webpackChunkkontokorrent\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","AccountType","async","postJson","url","body","token","init","method","headers","JSON","stringify","fetch","TokenRenewFailedException","constructor","networkError","InteractionRequiredException","ApiException","API_URL","environment","NeueBezahlungFailedException","BezahlungBearbeitenFailedException","BezahlungLoeschenFailedException","baseUrl","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","BezahlungStatus","groupBy","list","key","map","Map","forEach","item","k","collection","get","push","set","BeschreibungsVorschlaege","kontokorrentId","vorschlaege","type","filterBezahlungen","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","id","Object","values","KontokorrentSynchronizer","db","i","sorted","this","getAktionen","v","length","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","erweitern","summe","nenner","andere","c","n","request","bisLaufendeNummer","filter","bezahlungen","gespeicherte","zwischengespeicherte","getZwischengespeicherteBezahlungenForKontokorrent","kk","getKontokorrent","geteilteZahlungen","p","personen","e","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","Array","from","keys","gesamtNenner","reduce","gesamtSumme","g","getBalance","Score","personA","personB","value","Is","balanceList","entries","personId","PersonenBeziehungScoreBewerter","bevorzugteZahlungen","scores","getScores","max","getMax","bevorzugteZahlung","find","empfaengerPersonId","compare","x","y","xScore","yScore","Math","abs","Number","EPSILON","findeBesteZahlung","pA","pB","some","s","AusgleichsZahlung","isCloseTo","epsilon","AusgleichStatus","zahlungsBewerter","angewendeteZahlungen","anwenden","ausgleichsZahlungen","mussZahlungenAnwenden","mussZahlungen","zahlungen","z","bezahlenderStatus","gleicheAufloesen","bezahlender","empfaenger","p2","gleichheitErzeugen","moeglicheGleichheitsZahlungen","empfaengerKandidaten","empf","empfaengerKandidat","bezahlender2","best","istAufgeloest","getAusgleich","ausgleichZahlungen","flattenAusgleichZahlungen","concat","moeglicheZahlung","einfacheZahlungKandidaten","einfacheZahlung","teilzahlungKandidaten","teilzahlung","AusgleichNichtMoeglichError","AusgleichService","calc","ausgleichStatus","ausgleichOptions","geforderteZahlungen","KontokorrentGeoeffnet","KontokorrentBezahlungen","KontokorrentSynchronisieren","KontokorrentSynchronisiert","KontokorrentBalanceAktualisiert","KontokorrentNichtGefunden","oeffentlicherName","KontokorrentOeffnen","AusgleichBerechnen","AusgleichBerechnet","ausgleich","storeAdapter","dispatch","action","self","postMessage","msg","cb","upgrade","oldVersion","newVersion","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","objectStoreNames","contains","deleteObjectStore","close","withInitialized","getAll","keySelector","name","toLowerCase","localeCompare","mapped","unwrapped","Promise","resolve","reject","tx","transaction","onerror","err","console","error","oncomplete","objectStore","add","ev","log","preventDefault","stopPropagation","appState","kks","getKontokorrents","kontokorrents","existing","d","delete","newIds","ex","combined","getFromIndex","getAllFromIndex","clear","tokenType","t","lastTimeStamp","durability","store","timestamp","done","accountInfo","bezahlungId","aktion","status","m","accountInfoStore","setAccountInfo","getAccountInfo","clearAccountInfo","getAccessToken","updateAccessTokenIfNewer","apiClient","secret","ok","success","res","getAuthHeader","json","einladungsCode","params","encodeURIComponent","exists","ab","query","notfound","mapAktionen","zeitpunkt","Date","info","Error","anonym","tokenResponse","tokenInfo","expires","parse","google","beschreibungVorschlagActionCreator","resetCache","formatSearchString","replace","sameChars","min","beschreibungenCache","beschreibungen","eingabe","beschreibung","search","result","trim","r","occurence","formatted","indexOf","score","slice","kontokorrentSyncActionCreator","Gespeichert","Zwischengespeichert","calculateBalance","all","refreshBezahlungen","getLaufendeNummer","addAktionen","refreshKontokorrent","getPerOeffentlichName","setZuletztGesehenerKontokorrentId","kontokorrentSynchronisieren","addEventListener","kontokorrentOeffnen","getVorschlaege","ausgleichRechnen","process","data","catch","internalObjectKeys","hiddenKeys","exports","f","getOwnPropertyNames","O","fails","whitespaces","module","METHOD_NAME","requireObjectCoercible","toString","whitespace","ltrim","RegExp","rtrim","createMethod","TYPE","$this","string","start","end","$","$trim","target","proto","forced","forcedStringTrimMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","__webpack_exports__","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","definition","o","defineProperty","enumerable","chunkId","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}