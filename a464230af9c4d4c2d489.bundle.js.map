{"version":3,"file":"a464230af9c4d4c2d489.bundle.js","mappings":"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","sources":["webpack://kontokorrent/webpack/runtime/chunk loaded","webpack://kontokorrent/webpack/runtime/startup chunk dependencies","webpack://kontokorrent/./src/lib/AccountType.ts","webpack://kontokorrent/./src/api/postJson.ts","webpack://kontokorrent/./src/api/TokenRenewFailedException.ts","webpack://kontokorrent/./src/api/InteractionRequiredException.ts","webpack://kontokorrent/./src/api/ApiException.ts","webpack://kontokorrent/./src/environment.ts","webpack://kontokorrent/./src/api/NeueBezahlungFailedException.ts","webpack://kontokorrent/./src/api/BezahlungBearbeitenFailedException.ts","webpack://kontokorrent/./src/api/BezahlungLoeschenFailedException.ts","webpack://kontokorrent/./src/api/ApiClient.ts","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/state/State.ts","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/state/actions/BeschreibungVorschlagActionCreator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/lib/ausgleich/Score.ts","webpack://kontokorrent/./src/lib/ausgleich/balanceList.ts","webpack://kontokorrent/./src/lib/ausgleich/PersonenBeziehungScoreBewerter.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichsZahlung.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichStatus.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichNichtMoeglichError.ts","webpack://kontokorrent/./src/lib/ausgleich/AusgleichService.ts","webpack://kontokorrent/./src/state/actions/KontokorrentSyncActionCreator.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/./src/lib/AccountInfoStore.ts","webpack://kontokorrent/./node_modules/core-js/internals/object-get-own-property-names.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim-forced.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim.js","webpack://kontokorrent/./node_modules/core-js/internals/whitespaces.js","webpack://kontokorrent/./node_modules/core-js/modules/es.string.trim.js","webpack://kontokorrent/webpack/bootstrap","webpack://kontokorrent/webpack/runtime/define property getters","webpack://kontokorrent/webpack/runtime/ensure chunk","webpack://kontokorrent/webpack/runtime/get javascript chunk filename","webpack://kontokorrent/webpack/runtime/get mini-css chunk filename","webpack://kontokorrent/webpack/runtime/global","webpack://kontokorrent/webpack/runtime/hasOwnProperty shorthand","webpack://kontokorrent/webpack/runtime/publicPath","webpack://kontokorrent/webpack/runtime/importScripts chunk loading","webpack://kontokorrent/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(820).then(next);\n};","export enum AccountType {\n    google = \"google\",\n    anonym = \"anonym\"\n};\n","export async function postJson(url: string, body: any, token?: string) {\n    let init: RequestInit = {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    };\n    if (token) {\n        init.headers = { ...init.headers, \"Authorization\": `Bearer ${token}` };\n    }\n    return await fetch(url, init);\n}","export class TokenRenewFailedException {\n    constructor(public readonly networkError: boolean) {\n\n    }\n}","export class InteractionRequiredException {\n\n}\n\n","\nexport class ApiException {\n}\n","let API_URL;\nif (__ENVIRONMENT == \"local\") {\n    API_URL = \"https://kontokorrent.marik.ch\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    API_URL = \"https://kontokorrent.marik.ch\";\n}\nelse if (__ENVIRONMENT == \"gh-pagesv2\") {\n    API_URL = \"https://kontokorrent.marik.ch\";\n}\nelse {\n    API_URL = \"https://kontokorrent.marik.ch\";\n}\n\nexport const environment = {\n    API_URL: API_URL\n};\n","\nexport class NeueBezahlungFailedException {\n}\n\n\n","\nexport class BezahlungBearbeitenFailedException {\n}\n","\nexport class BezahlungLoeschenFailedException {\n}\n","import { postJson } from \"./postJson\";\nimport { AccountType } from \"../lib/AccountType\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentInfo } from \"./KontokorrentInfo\";\nimport { NeuerKontokorrentRequest } from \"./NeuerKontokorrentRequest\";\nimport { TokenRenewFailedException } from \"./TokenRenewFailedException\";\nimport { InteractionRequiredException } from \"./InteractionRequiredException\";\nimport { ApiException } from \"./ApiException\";\nimport { Aktion } from \"./Aktion\";\nimport { environment } from \"../environment\";\nimport { NeueBezahlungRequest } from \"./NeueBezahlungRequest\";\nimport { NeueBezahlungFailedException } from \"./NeueBezahlungFailedException\";\nimport { BezahlungBearbeitenRequest } from \"./BezahlungBearbeitenRequest\";\nimport { BezahlungBearbeitenFailedException } from \"./BezahlungBearbeitenFailedException\";\nimport { BezahlungLoeschenFailedException } from \"./BezahlungLoeschenFailedException\";\n\nconst baseUrl = environment.API_URL;\n\nexport class ApiClient {\n\n    constructor(private accountInfoStore: AccountInfoStore) {\n\n    }\n\n    async neuerBenutzer(id: string, secret: string) {\n        try {\n            let res = await postJson(`${baseUrl}/api/v2/accounts`, { id, secret });\n            if (!res.ok) {\n                return { success: false };\n            }\n            return { success: true };\n        }\n        catch(err) {\n            return { success: false };\n        }\n    }\n\n    async getUserInfo() {\n        let res = await fetch(`${baseUrl}/api/v2/userinfo`, { headers: await this.getAuthHeader() });\n        return await res.json();\n    }\n\n    private async getAuthHeader() {\n        return { \"Authorization\": `Bearer ${await this.getAccessToken()}` };\n    }\n\n    async kontokorrentHinzufuegen(oeffentlicherName: string, einladungsCode: string) {\n        let params = \"\";\n        if (oeffentlicherName) {\n            params = `oeffentlicherName=${encodeURIComponent(oeffentlicherName)}`;\n        }\n        else {\n            params = `einladungsCode=${encodeURIComponent(einladungsCode)}`;\n        }\n        let headers = await this.getAuthHeader();\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents?${params}`, { method: \"PUT\", headers: headers });\n        if (res.status == 404) {\n            return null;\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n    async kontokorrentsAuflisten() {\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents`, { headers: await this.getAuthHeader() });\n        if (!res.ok) {\n            throw new ApiException();\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n\n    async neuerKontokorrent(request: NeuerKontokorrentRequest) {\n        let res = await postJson(`${baseUrl}/api/v2/kontokorrents`, request, await this.getAccessToken());\n        if (res.status == 422) {\n            return { success: false, exists: true };\n        }\n        else if (res.ok) {\n            return { success: true };\n        }\n        return { success: false };\n    }\n\n    async getAktionen(kontokorrentId: string, ab?: number) {\n        let query = ab ? `?ab=${ab}` : \"\";\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen${query}`, { headers: await this.getAuthHeader() });\n        if (res.status == 404) {\n            return {\n                success: false,\n                notfound: true\n            };\n        }\n        else if (res.ok) {\n            let aktionen: Aktion[] = await res.json();\n            return {\n                success: true,\n                aktionen: this.mapAktionen(aktionen)\n            }\n        }\n    }\n\n    private mapAktionen(aktionen : Aktion[]) : Aktion[] {\n        for (let a of aktionen) {\n            if (a.bezahlung) {\n                a.bezahlung.zeitpunkt = new Date(a.bezahlung.zeitpunkt);\n            }\n        }\n        return aktionen;\n    }\n\n    async neueBezahlung(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.hinzufuegenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new NeueBezahlungFailedException();\n    }\n\n    async bezahlungLoeschen(kontokorrentId: string, bezahlungId:string) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.loeschenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify({id:bezahlungId})\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungLoeschenFailedException();\n    }\n\n    async bezahlungBearbeiten(kontokorrentId: string, request: BezahlungBearbeitenRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.bearbeitenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungBearbeitenFailedException();\n    }\n\n\n    private async getAccessToken() {\n        let info = await this.accountInfoStore.get();\n        if (null == info) {\n            throw new Error(\"Keine Account Information gespeichert.\");\n        }\n        if (info.type == AccountType.anonym) {\n            let tokenInfo = await this.accountInfoStore.getAccessToken(\"anonymous\");\n            if (null != tokenInfo) {\n                let { token, expires } = JSON.parse(tokenInfo.value);\n                if (token && expires && expires >= +new Date()) {\n                    return token;\n                }\n            }\n            let tokenResponse;\n            try {\n                let res = await postJson(`${baseUrl}/api/v2/token`, { id: info.id, secret: info.secret });\n                if (!res.ok) {\n                    throw new TokenRenewFailedException(false);\n                }\n                tokenResponse = await res.json();\n            }\n            catch(err) {\n                throw new TokenRenewFailedException(true);\n            }\n            await this.accountInfoStore.updateAccessTokenIfNewer(\"anonymous\", JSON.stringify(tokenResponse), tokenInfo?.timestamp);\n            return tokenResponse.token;\n        }\n        else if (info.type == AccountType.google) {\n            throw new InteractionRequiredException();\n            // let flow = new OAuth2PopupFlow({\n            //     authorizationUri: \"https://accounts.google.com/o/oauth2/v2/auth/.well-known/openid-configuration\",\n            //     clientId: \"82890837151-n0e81vsn3ns2qn1ksh7bdohmnlau468k.apps.googleusercontent.com\",\n            //     redirectUri: \"http://localhost:4200\",\n            //     scope: \"openid\",\n            //     responseType: \"id_token\",\n            //     additionalAuthorizationParameters: { \"login_hint\": info.id },\n            //     accessTokenStorageKey: \"access_token_google\"\n            // });\n            // return await flow.token();\n        }\n        else {\n            throw new Error(`Account Typ ${info.type} unbekannt`);\n        }\n    }\n}","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\nimport { BearbeitungsStatus } from \"./BearbeitungsStatus\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        let mapped = aktionen\n            .map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            });\n        return await this.withInitialized(db => {\n            const unwrapped = unwrap(<IDBPDatabase>db);\n            return new Promise((resolve, reject) => {\n                const tx = unwrapped.transaction(AktionenStore, \"readwrite\");\n                tx.onerror = err => {\n                    console.error(\"addAktionen failed\", err, tx.error);\n                    reject(tx.error);\n                };\n                tx.oncomplete = () => {\n                    resolve();\n                }\n                for (let a of mapped) {\n                    let request = tx.objectStore(AktionenStore).add(a);\n                    request.onerror = ev => {\n                        if (request.error.name == \"ConstraintError\") {\n                            console.log(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} bereits gespeichert.`, ev, request.error);\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        } else {\n                            console.error(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} konnte nicht gespeichert werden.`, ev, request.error);\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return (await db.getAll(NeueBezahlungenStore));\n        });\n    }\n\n    async getBezahlungAktion(kontokorrentId: string, bezahlungId: string): Promise<AktionDbModel> {\n        return await this.withInitialized(async db => {\n            var aktionen = db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            return (await aktionen).find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n        });\n    }\n\n    async getBearbeitungsStatus(kontokorrentId: string, bezahlungId: string): Promise<{ aktion: AktionDbModel, status: BearbeitungsStatus }> {\n        return await this.withInitialized(async db => {\n            let aktionen: AktionDbModel[] = await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            let aktion = aktionen.find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n            if (!aktion) {\n                let neueBezahlungen: NeueBezahlungDbModel[] = await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n                let neueBezahlung = neueBezahlungen.find(a => a.id == bezahlungId);\n                if (neueBezahlung) {\n                    return { aktion: null, status: BearbeitungsStatus.Zwischengespeichert };\n                }\n                return { aktion: null, status: BearbeitungsStatus.NichtGefunden };\n            }\n            let bearbeitendeAktion = aktionen.find(a => a.bearbeiteteBezahlungId == bezahlungId);\n            if (null != bearbeitendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Bearbeitet };\n            }\n            let loeschendeAktion = aktionen.find(a => a.geloeschteBezahlungId == bezahlungId);\n            if (null != loeschendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Geloescht };\n            }\n            return { aktion: aktion, status: BearbeitungsStatus.Bearbeitbar };\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","import { AccountInfo } from \"../lib/AccountInfo\";\nimport { KontokorrentAusgleich } from \"../lib/ausgleich/KontokorrentAusgleich\";\nimport { BearbeitungsStatus } from \"../lib/BearbeitungsStatus\";\n\nexport interface AccountState {\n    accountCreated: boolean,\n    accountCreating: boolean,\n    accountCreationFailed: boolean\n    loginExpired: boolean;\n    accountInfo: AccountInfo\n}\n\nexport interface KontokorrentsState {\n    kontokorrents: { [id: string]: KontokorrentState };\n    hinzufuegen: boolean;\n    listeLaden: boolean;\n    hinzufuegenFailed: {\n        kontokorrentNotFound: boolean\n    }\n    creating: boolean;\n    creationFailed: { exists: boolean };\n    activeKontokorrentId: string;\n    nichtGefunden: {\n        oeffentlicherName: string\n    }\n}\n\nexport interface Person {\n    name: string;\n    id: string;\n    balance: number;\n}\n\nexport enum BezahlungStatus {\n    Zwischengespeichert = \"zwischengespeichert\",\n    Speichern = \"speichern\",\n    Gespeichert = \"gespeichert\"\n}\n\nexport interface Bezahlung {\n    id: string;\n    zeitpunkt: Date;\n    bezahlendePersonId: string;\n    empfaengerIds: string[];\n    wert: number;\n    beschreibung: string;\n    status: BezahlungStatus\n}\n\nexport const enum RequestStatus {\n    InProgress,\n    Success,\n    Failed\n}\n\nexport interface AngezeigteBezahlungState {\n    bearbeitungsStatus: BearbeitungsStatus;\n    updateStatus?: RequestStatus;\n    deleteStatus?: RequestStatus;\n}\n\nexport interface KontokorrentState {\n    id: string;\n    name: string;\n    oeffentlicherName: string;\n    personen: Person[];\n    bezahlungen: Bezahlung[];\n    synchronisieren: boolean;\n    bezahlungAnlegen: RequestStatus;\n    angezeigteBezahlung: { [id: string]: AngezeigteBezahlungState }\n    ausgleichBerechnen: boolean;\n    ausgleich: KontokorrentAusgleich;\n}\n\nexport interface BeschreibungVorschlagState {\n    kontokorrentId: string;\n    vorschlaege: string[];\n}\n\nexport interface State {\n    account: AccountState\n    kontokorrents: KontokorrentsState;\n    beschreibungVorschlaege: BeschreibungVorschlagState;\n}\n","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { Store } from \"../lib/Store\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { ActionNames } from \"./ActionNames\";\nimport { Action } from \"../lib/Action\";\nimport { groupBy } from \"../../utils/groupBy\";\n\nexport class BeschreibungsVorschlaege implements Action {\n    readonly type = ActionNames.BeschreibungsVorschlaege;\n    constructor(public kontokorrentId: string, public vorschlaege: string[]) {\n\n    }\n}\n\nexport type BeschreibungVorschlagActions =\n    | BeschreibungsVorschlaege;\n\nexport class BeschreibungVorschlagActionCreator {\n    private beschreibungenCache: { kontokorrentId: string, beschreibungen: { search: string, result: string, occurence: number }[] };\n    constructor(private db: KontokorrentDatabase, private store: Store) {\n        this.resetCache();\n    }\n\n\n    private formatSearchString(s: string) {\n        return s.toLowerCase().replace(/\\s|-/g, \"\");\n    }\n\n    private sameChars(s: string, d: string) {\n        let i;\n        for (i = 0; i < Math.min(s.length, d.length); i++) {\n            if (s[i] != d[i]) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    resetCache() {\n        this.beschreibungenCache = { kontokorrentId: null, beschreibungen: [] };\n    }\n\n    async getVorschlaege(kontokorrentId: string, eingabe: string) {\n        if (this.beschreibungenCache.kontokorrentId != kontokorrentId) {\n            let aktionen = await this.db.getAktionen(kontokorrentId);\n            let beschreibungen = aktionen.filter(a => null != a.bezahlung?.beschreibung).map(a => {\n                return { search: this.formatSearchString(a.bezahlung.beschreibung), result: a.bezahlung.beschreibung.trim() }\n            });\n            this.beschreibungenCache.kontokorrentId = kontokorrentId;\n            let map = groupBy(beschreibungen, \"search\");\n            this.beschreibungenCache.beschreibungen = Array.from(map.entries()).map(([search, r]) => {\n\n                return {\n                    search,\n                    result: r[0].result,\n                    occurence: r.length\n                };\n            }).sort((a, b) => b.occurence - a.occurence);\n        }\n        if (eingabe) {\n            let formatted = this.formatSearchString(eingabe);\n            let vorschlaege = this.beschreibungenCache.beschreibungen\n                .filter(({ search }) => search.indexOf(formatted) > -1)\n                .map(({ search, result }) => {\n                    return { result, score: this.sameChars(formatted, search) }\n                }).sort((a, b) => b.score - a.score);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege.map(b => b.result)));\n        }\n        else {\n            let vorschlaege = this.beschreibungenCache.beschreibungen.slice(0, 10).map(b => b.result);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege));\n        }\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let sorted = aktionen.map(v => v.laufendeNummer).sort((a, b) => a - b);\n        let i: number;\n        for (i = 0; i < sorted.length - 1; i++) {\n            if (sorted[i] + 1 !== sorted[i + 1]) {\n                break;\n            }\n        }\n        return sorted[i];\n    }\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\ntype Bezahlung = { empfaengerIds: string[], bezahlendePersonId: string, wert: number };\n\ninterface KontokorrentBalanceRequest {\n    kontokorrentId: string;\n    zwischengespeicherte: boolean;\n    bisLaufendeNummer: null | number;\n}\n\ninterface KontokorrentBalanceResult {\n    bezahlungen: Bezahlung[];\n    balance: KontokorrentBalance;\n}\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    private erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async getBalance(request: KontokorrentBalanceRequest): Promise<KontokorrentBalanceResult> {\n        let aktionen = await this.db.getAktionen(request.kontokorrentId);\n        if (request.bisLaufendeNummer) {\n            aktionen = aktionen.filter(a => a.laufendeNummer <= request.bisLaufendeNummer);\n        }\n        let gespeicherte: Bezahlung[] = filterBezahlungen(aktionen);\n        let bezahlungen: Bezahlung[];\n        let zwischengespeicherte: Bezahlung[] = await this.db.getZwischengespeicherteBezahlungenForKontokorrent(request.kontokorrentId);\n        if (request.zwischengespeicherte) {\n            bezahlungen = [...zwischengespeicherte, ...gespeicherte];\n        } else {\n            bezahlungen = gespeicherte;\n        }\n        let kk = await this.db.getKontokorrent(request.kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return {\n            bezahlungen: bezahlungen,\n            balance: balance\n        };\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        return (await this.getBalance({\n            kontokorrentId: kontokorrentId,\n            zwischengespeicherte: true,\n            bisLaufendeNummer: null\n        })).balance;\n    }\n}","\nexport class Score {\n    constructor(public personA: string, public personB: string, public value: number) {\n    }\n    public Is(a: string, b: string): boolean {\n        return (this.personA == a && this.personB == b) || (this.personA == b && this.personB == a);\n    }\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\n\n\nexport function balanceList(balance: KontokorrentBalance) {\n    return Object.entries(balance).map(([k, v]) => {\n        return {\n            personId: k,\n            wert: v\n        };\n    });\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\nimport { ZahlungsBewerter } from \"./ZahlungsBewerter\";\nimport { GeforderteZahlung } from \"./GeforderteZahlung\";\nimport { AusgleichsZahlung } from \"./AusgleichsZahlung\";\nimport { Score } from \"./Score\";\nimport { balanceList } from \"./balanceList\";\n\nfunction getMax(a: number[]) {\n    let max = a[0];\n    for (let v of a) {\n        if (v > max) {\n            max = v;\n        }\n    }\n    return max;\n}\n\nexport class PersonenBeziehungScoreBewerter implements ZahlungsBewerter {\n    private scores: Score[];\n\n    constructor(balance: KontokorrentBalance, bezahlungen: {\n        empfaengerIds: string[];\n        bezahlendePersonId: string;\n    }[], bevorzugteZahlungen: GeforderteZahlung[]) {\n        this.scores = this.getScores(balance, bezahlungen);\n        var max = getMax(this.scores.map(v => v.value));\n        max += 1.0;\n        for (let bevorzugteZahlung of bevorzugteZahlungen) {\n            this.scores.find(v => v.Is(bevorzugteZahlung.bezahlendePersonId, bevorzugteZahlung.empfaengerPersonId)).value = max;\n        }\n    }\n\n    private compare(x: AusgleichsZahlung, y: AusgleichsZahlung): number {\n        if (null == x || null == y) {\n            return -1;\n        }\n        var xScore = this.scores.find(v => v.Is(x.bezahlendePersonId, x.empfaengerPersonId)).value;\n        var yScore = this.scores.find(v => v.Is(y.bezahlendePersonId, y.empfaengerPersonId)).value;\n        if (Math.abs(xScore - yScore) < Number.EPSILON) {\n            return 0;\n        }\n        else if (xScore < yScore) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n\n    findeBesteZahlung(a: AusgleichsZahlung[]): AusgleichsZahlung {\n        return a.sort((a, b) => this.compare(b, a))[0];\n    }\n\n    private getScores(balance: KontokorrentBalance, bezahlungen: {\n        empfaengerIds: string[];\n        bezahlendePersonId: string;\n    }[]) {\n        let scores: Score[] = [];\n        let list = balanceList(balance);\n        for (let pA of list) {\n            for (let pB of list) {\n                if (pB.personId != pA.personId) {\n                    if (!scores.some(s => s.Is(pA.personId, pB.personId))) {\n                        scores.push(new Score(pA.personId, pB.personId, 0));\n                    }\n                }\n            }\n        }\n\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                if (b.bezahlendePersonId != e) {\n                    var score = scores.find(s => s.Is(b.bezahlendePersonId, e));\n                    score.value += 1.0 / b.empfaengerIds.length;\n                }\n            }\n        }\n        return scores;\n    }\n}\n","\nexport class AusgleichsZahlung {\n    constructor(public bezahlendePersonId: string,\n        public empfaengerPersonId: string,\n        public wert: number) {\n    }\n}\n","import { KontokorrentBalance } from \"../KontokorrentBalance\";\nimport { AusgleichsZahlung } from \"./AusgleichsZahlung\";\nimport { ZahlungsBewerter } from \"./ZahlungsBewerter\";\nimport { GeforderteZahlung } from \"./GeforderteZahlung\";\nimport { KontokorrentAusgleich } from \"./KontokorrentAusgleich\";\nimport { balanceList } from \"./balanceList\";\n\nfunction isCloseTo(a: number, b: number, epsilon?: number): boolean {\n    return Math.abs(a - b) < (epsilon || Number.EPSILON);\n}\n\n\nexport class AusgleichStatus {\n    private angewendeteZahlungen: AusgleichsZahlung[];\n\n    constructor(private balance: KontokorrentBalance, private zahlungsBewerter: ZahlungsBewerter) {\n        this.angewendeteZahlungen = [];\n    }\n\n    private anwenden(ausgleichsZahlungen: AusgleichsZahlung[]) {\n        let b = { ...this.balance };\n        for (let a of ausgleichsZahlungen) {\n            b[a.bezahlendePersonId] -= a.wert;\n            b[a.empfaengerPersonId] += a.wert;\n        }\n        this.balance = b;\n        this.angewendeteZahlungen = [...this.angewendeteZahlungen, ...ausgleichsZahlungen];\n    }\n\n    mussZahlungenAnwenden(mussZahlungen: GeforderteZahlung[]) {\n        let zahlungen = mussZahlungen.map(z => {\n            let bezahlenderStatus = this.balance[z.bezahlendePersonId];\n            return new AusgleichsZahlung(z.bezahlendePersonId, z.empfaengerPersonId, bezahlenderStatus);\n        });\n        this.anwenden(zahlungen);\n    }\n\n\n    private getGleicheAufloesenCandidate() {\n        let list = balanceList(this.balance);\n        let empfaenger = list.filter(e => e.wert < 0);\n        let bezahler = list.filter(e => e.wert > 0);\n        let closestDiff = Infinity;\n        let closestKombination: AusgleichsZahlung[] = [];\n        for (let e of empfaenger) {\n            for (let i = 1; i < 2 ** bezahler.length; i++) {\n                let bezahlerKombination = bezahler.filter((b, index) => (i & (1 << index)) > 0);\n                let summe = bezahlerKombination.reduce((a, b) => a + b.wert, 0);\n                let aktDiff = Math.abs(summe + e.wert);\n                if (aktDiff < closestDiff) {\n                    closestDiff = aktDiff;\n                    closestKombination = bezahlerKombination.map(b => new AusgleichsZahlung(b.personId, e.personId, b.wert));\n                }\n                closestDiff = Math.min(closestDiff, Math.abs(summe + e.wert));\n            }\n        }\n        if (closestDiff < 0.5) {\n            return closestKombination;\n        }\n        return null;\n    }\n\n    gleicheAufloesen() {\n        let zahlungen = this.getGleicheAufloesenCandidate();\n        while (zahlungen) {\n            this.anwenden(zahlungen);\n            zahlungen = this.getGleicheAufloesenCandidate();\n        }\n    }\n\n    gleichheitErzeugen() {\n        let list = balanceList(this.balance);\n        let moeglicheGleichheitsZahlungen = list.filter(p => p.wert > 0).map(bezahlender => {\n            let empfaengerKandidaten = list.filter(empf => -empf.wert > bezahlender.wert);\n            for (let empfaengerKandidat of empfaengerKandidaten) {\n                let ausgleichMoeglich = list.some(bezahlender2 => bezahlender.personId != bezahlender2.personId\n                    && bezahlender2.wert > 0\n                    && isCloseTo(empfaengerKandidat.wert + bezahlender.wert, -bezahlender2.wert));\n                if (ausgleichMoeglich) {\n                    return new AusgleichsZahlung(bezahlender.personId, empfaengerKandidat.personId, bezahlender.wert);\n                }\n            }\n            return null;\n        }).filter(z => z != null);\n        if (moeglicheGleichheitsZahlungen.length > 0) {\n            let best = this.zahlungsBewerter.findeBesteZahlung(moeglicheGleichheitsZahlungen);\n            this.anwenden([best]);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    istAufgeloest(): boolean {\n        return !Object.values(this.balance).some(s => !isCloseTo(s, 0, 0.05));\n    }\n\n    getAusgleich(): KontokorrentAusgleich {\n        return {\n            ausgleichZahlungen: this.angewendeteZahlungen\n        };\n    }\n\n    private flattenAusgleichZahlungen(z: AusgleichsZahlung[][]) {\n        return z.reduce((a, b) => a.concat(b), []);\n    }\n\n\n    moeglicheZahlung() {\n        let list = balanceList(this.balance);\n        let einfacheZahlungKandidaten = list.filter(b => b.wert > 0)\n            .map(bezahlender => {\n                return list.filter(empf => empf.personId != bezahlender.personId && -empf.wert > bezahlender.wert)\n                    .map(empfaenger => new AusgleichsZahlung(bezahlender.personId, empfaenger.personId, bezahlender.wert));\n            });\n\n        let einfacheZahlung = this.zahlungsBewerter.findeBesteZahlung(this.flattenAusgleichZahlungen(einfacheZahlungKandidaten));\n        if (null != einfacheZahlung) {\n            this.anwenden([einfacheZahlung]);\n            return;\n        }\n        let teilzahlungKandidaten = list.filter(b => b.wert > 0)\n            .map(bezahlender => {\n                return list.filter(empf => empf.personId != bezahlender.personId && empf.wert < 0)\n                    .map(empfaenger => new AusgleichsZahlung(bezahlender.personId, empfaenger.personId, Math.abs(empfaenger.wert)));\n            });\n        let teilzahlung = this.zahlungsBewerter.findeBesteZahlung(this.flattenAusgleichZahlungen(teilzahlungKandidaten));\n        if (null != teilzahlung) {\n            this.anwenden([teilzahlung]);\n        }\n    }\n}\n","\nexport class AusgleichNichtMoeglichError {\n}\n","import { BalanceCalculator } from \"../BalanceCalculator\";\nimport { KontokorrentDatabase } from \"../KontokorrentDatabase\";\nimport { PersonenBeziehungScoreBewerter } from \"./PersonenBeziehungScoreBewerter\";\nimport { AusgleichRequest } from \"./AusgleichRequest\";\nimport { KontokorrentAusgleich } from \"./KontokorrentAusgleich\";\nimport { AusgleichStatus } from \"./AusgleichStatus\";\nimport { AusgleichNichtMoeglichError } from \"./AusgleichNichtMoeglichError\";\n\nexport class AusgleichService {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    public async getAusgleich(request: AusgleichRequest): Promise<KontokorrentAusgleich> {\n        let calc = new BalanceCalculator(this.db);\n        let balance = await calc.getBalance({\n            kontokorrentId: request.kontokorrentId,\n            zwischengespeicherte: false,\n            bisLaufendeNummer: request.bisLaufendeNummer,\n        });\n        let ausgleichStatus = new AusgleichStatus(balance.balance, new PersonenBeziehungScoreBewerter(balance.balance, balance.bezahlungen, request.ausgleichOptions.geforderteZahlungen));\n        ausgleichStatus.mussZahlungenAnwenden(request.ausgleichOptions.mussZahlungen);\n        for (let i = 0; i < 1000; i++) {\n            if (ausgleichStatus.istAufgeloest()) {\n                return ausgleichStatus.getAusgleich();\n            }\n            ausgleichStatus.gleicheAufloesen();\n            if (!ausgleichStatus.istAufgeloest()) {\n                if (!ausgleichStatus.gleichheitErzeugen()) {\n                    ausgleichStatus.moeglicheZahlung();\n                }\n            }\n        }\n        throw new AusgleichNichtMoeglichError();\n    }\n}\n","import { Store } from \"../lib/Store\";\nimport { ApiClient } from \"../../api/ApiClient\";\nimport { Action } from \"../lib/Action\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { Bezahlung, BezahlungStatus } from \"../State\";\nimport { filterBezahlungen } from \"../../lib/filterBezahlungen\";\nimport { ActionNames } from \"./ActionNames\";\nimport { KontokorrentSynchronizer } from \"../../lib/KontokorrentSynchronizer\";\nimport { BalanceCalculator } from \"../../lib/BalanceCalculator\";\nimport { KontokorrentBalance } from \"../../lib/KontokorrentBalance\";\nimport { GeforderteZahlung } from \"../../lib/ausgleich/GeforderteZahlung\";\nimport { AusgleichOptions } from \"../../lib/ausgleich/AusgleichOptions\";\nimport { AusgleichService } from \"../../lib/ausgleich/AusgleichService\";\nimport { KontokorrentAusgleich } from \"../../lib/ausgleich/KontokorrentAusgleich\";\n\nexport class KontokorrentGeoeffnet implements Action {\n    readonly type = ActionNames.KontokorrentGeoeffnet;\n    constructor(public id: string) {\n\n    }\n}\n\nexport class KontokorrentBezahlungen implements Action {\n    readonly type = ActionNames.KontokorrentBezahlungen;\n    constructor(public kontokorrentId: string, public bezahlungen: Bezahlung[]) {\n\n    }\n}\n\nexport class KontokorrentSynchronisieren implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisieren;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentSynchronisiert implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisiert;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentBalanceAktualisiert implements Action {\n    readonly type = ActionNames.KontokorrentBalanceAktualisiert;\n    constructor(public kontokorrentId: string, public balance: KontokorrentBalance) {\n\n    }\n}\n\nexport class KontokorrentNichtGefunden implements Action {\n    readonly type = ActionNames.KontokorrentNichtGefunden;\n    constructor(public oeffentlicherName: string) {\n\n    }\n}\n\nexport class KontokorrentOeffnen implements Action {\n    readonly type = ActionNames.KontokorrentOeffnen;\n    constructor(public oeffentlicherName: string) {\n\n    }\n}\n\nexport class AusgleichBerechnen implements Action {\n    readonly type = ActionNames.AusgleichBerechnen;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class AusgleichBerechnet implements Action {\n    readonly type = ActionNames.AusgleichBerechnet;\n    constructor(public kontokorrentId: string, public ausgleich: KontokorrentAusgleich) {\n\n    }\n}\n\nexport type KontokorrentSyncActions =\n    | KontokorrentGeoeffnet\n    | KontokorrentBezahlungen\n    | KontokorrentSynchronisieren\n    | KontokorrentSynchronisiert\n    | KontokorrentBalanceAktualisiert\n    | KontokorrentNichtGefunden\n    | KontokorrentOeffnen\n    | AusgleichBerechnen\n    | AusgleichBerechnet;\n\nexport class KontokorrentSyncActionCreator {\n\n    constructor(private store: Store,\n        private apiClient: ApiClient,\n        private db: KontokorrentDatabase) {\n\n    }\n    private async refreshBezahlungen(id: string) {\n        let aktionen = filterBezahlungen(await this.db.getAktionen(id)).map(b => {\n            return {\n                ...b,\n                status: BezahlungStatus.Gespeichert\n            };\n        });\n        let zwischengespeicherte = (await this.db.getZwischengespeicherteBezahlungenForKontokorrent(id)).map(b => {\n            let x: Bezahlung = {\n                status: BezahlungStatus.Zwischengespeichert,\n                beschreibung: b.beschreibung,\n                bezahlendePersonId: b.bezahlendePersonId,\n                empfaengerIds: b.empfaengerIds,\n                id: b.id,\n                wert: b.wert,\n                zeitpunkt: b.zeitpunkt\n            };\n            return x;\n        }).filter(b => !aktionen.some(a => a.id == b.id));\n        this.store.dispatch(new KontokorrentBezahlungen(id, [...aktionen, ...zwischengespeicherte]));\n    }\n\n    private async calculateBalance(id: string) {\n        let balance = await (new BalanceCalculator(this.db).calculateBalance(id));;\n        this.store.dispatch(new KontokorrentBalanceAktualisiert(id, balance));\n    }\n\n    private async refreshKontokorrent(id: string) {\n        await Promise.all([this.refreshBezahlungen(id), this.calculateBalance(id)]);\n    }\n\n    private async kontokorrentSynchronisieren(id: string) {\n        this.store.dispatch(new KontokorrentSynchronisieren(id));\n        let laufendeNummer = await (new KontokorrentSynchronizer(this.db).getLaufendeNummer(id));\n        let res = await this.apiClient.getAktionen(id, laufendeNummer);\n        if (res.success) {\n            await this.db.addAktionen(id, res.aktionen);\n            if (res.aktionen.length > 0) {\n                await this.refreshKontokorrent(id);\n            }\n        }\n        this.store.dispatch(new KontokorrentSynchronisiert(id));\n    }\n\n\n\n    async kontokorrentOeffnen(oeffentlicherName: string) {\n        this.store.dispatch(new KontokorrentOeffnen(oeffentlicherName));\n        let kk = await this.db.getPerOeffentlichName(oeffentlicherName);\n        if (null != kk) {\n            this.store.dispatch(new KontokorrentGeoeffnet(kk.id));\n            await Promise.all([this.db.setZuletztGesehenerKontokorrentId(kk.id), this.refreshKontokorrent(kk.id)]);\n            await this.kontokorrentSynchronisieren(kk.id);\n        } else {\n            this.store.dispatch(new KontokorrentNichtGefunden(oeffentlicherName));\n        }\n    }\n\n    async ausgleichRechnen(oeffentlicherName: string, ausgleichOptions: AusgleichOptions) {\n        let kk = await this.db.getPerOeffentlichName(oeffentlicherName);\n        if (null != kk) {\n            this.store.dispatch(new AusgleichBerechnen(kk.id));\n            await this.kontokorrentSynchronisieren(kk.id);\n            let ausgleich = await (new AusgleichService(this.db).getAusgleich({\n                ausgleichOptions: ausgleichOptions,\n                bisLaufendeNummer: null,\n                kontokorrentId: kk.id\n            }));\n            this.store.dispatch(new AusgleichBerechnet(kk.id, ausgleich));\n        } else {\n            this.store.dispatch(new KontokorrentNichtGefunden(oeffentlicherName));\n        }\n    }\n}","import { ApiClient } from \"../api/ApiClient\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { AusgleichOptions } from \"../lib/ausgleich/AusgleichOptions\";\nimport { GeforderteZahlung } from \"../lib/ausgleich/GeforderteZahlung\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { BeschreibungVorschlagActionCreator } from \"../state/actions/BeschreibungVorschlagActionCreator\";\nimport { KontokorrentSyncActionCreator } from \"../state/actions/KontokorrentSyncActionCreator\";\nimport { Action } from \"../state/lib/Action\";\n\nlet storeAdapter = {\n    dispatch(action: Action): void {\n        self.postMessage({ type: \"statedispatch\", msg: action });\n    }\n}\n\nexport const enum WorkerMessageType {\n    KontokorrentOeffnen,\n    GetBeschreibungVorschlaege,\n    ResetBeschreibungenCache,\n    AusgleichRechnen\n}\n\nexport interface KontokorrentOeffnenMessage {\n    type: WorkerMessageType.KontokorrentOeffnen;\n    oeffentlicherName: string;\n}\n\nexport interface GetBeschreibungVorschlaegeMessage {\n    type: WorkerMessageType.GetBeschreibungVorschlaege;\n    kontokorrentId: string;\n    eingabe: string;\n}\nexport interface ResetBeschreibungenCacheMessage {\n    type: WorkerMessageType.ResetBeschreibungenCache;\n}\nexport interface AusgleichRechnenMessage {\n    type: WorkerMessageType.AusgleichRechnen;\n    oeffentlicherName: string;\n    ausgleichOptions: AusgleichOptions;\n}\n\ntype WorkerMessage = KontokorrentOeffnenMessage\n    | GetBeschreibungVorschlaegeMessage\n    | ResetBeschreibungenCacheMessage\n    | AusgleichRechnenMessage;\n\nconst db = new KontokorrentDatabase();\nconst accountInfoStore = new AccountInfoStore(db);\nconst apiClient = new ApiClient(accountInfoStore);\nconst beschreibungVorschlagActionCreator = new BeschreibungVorschlagActionCreator(db, storeAdapter);\nconst kontokorrentSyncActionCreator = new KontokorrentSyncActionCreator(storeAdapter, apiClient, db);\n\nasync function process(msg: WorkerMessage) {\n    switch (msg.type) {\n        case WorkerMessageType.KontokorrentOeffnen:\n            await kontokorrentSyncActionCreator.kontokorrentOeffnen(msg.oeffentlicherName);\n            break;\n        case WorkerMessageType.GetBeschreibungVorschlaege:\n            await beschreibungVorschlagActionCreator.getVorschlaege(msg.kontokorrentId, msg.eingabe);\n            break;\n        case WorkerMessageType.ResetBeschreibungenCache:\n            beschreibungVorschlagActionCreator.resetCache();\n            break;\n        case WorkerMessageType.AusgleichRechnen:\n            await kontokorrentSyncActionCreator.ausgleichRechnen(msg.oeffentlicherName, msg.ausgleichOptions);\n            break;\n    }\n}\n\nself.addEventListener(\"message\", e => {\n    let msg: WorkerMessage = e.data;\n    process(msg).catch(err => console.error(err));\n});","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","import { AccountInfo } from \"./AccountInfo\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class AccountInfoStore {\n    constructor(private db: KontokorrentDatabase) {\n\n    }\n\n    async set(accountInfo: AccountInfo): Promise<void> {\n        await this.db.setAccountInfo(accountInfo);\n    }\n    async get(): Promise<AccountInfo> {\n        return await this.db.getAccountInfo();\n    }\n    async clear(): Promise<void> {\n        await this.db.clearAccountInfo();\n    }\n\n    async getAccessToken(tokenType: \"google\" | \"anonymous\"): Promise<{ timestamp: number, value: string }> {\n        return await this.db.getAccessToken(tokenType);\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number) {\n        return await this.db.updateAccessTokenIfNewer(tokenType, value, lastTimeStamp);\n    }\n}\n\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","var fails = require('../internals/fails');\nvar whitespaces = require('../internals/whitespaces');\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","'use strict';\nvar $ = require('../internals/export');\nvar $trim = require('../internals/string-trim').trim;\nvar forcedStringTrimMethod = require('../internals/string-trim-forced');\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [820], function() { return __webpack_require__(3483); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + \"0cdd927a1d4532914d47\" + \".bundle.js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t81: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkontokorrent\"] = self[\"webpackChunkkontokorrent\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","AccountType","async","postJson","url","body","token","init","method","headers","JSON","stringify","fetch","TokenRenewFailedException","constructor","networkError","InteractionRequiredException","ApiException","API_URL","environment","NeueBezahlungFailedException","BezahlungBearbeitenFailedException","BezahlungLoeschenFailedException","baseUrl","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","BezahlungStatus","groupBy","list","key","map","Map","forEach","item","k","collection","get","push","set","BeschreibungsVorschlaege","kontokorrentId","vorschlaege","type","filterBezahlungen","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","id","Object","values","KontokorrentSynchronizer","db","i","sorted","this","getAktionen","v","length","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","erweitern","summe","nenner","andere","c","n","request","bisLaufendeNummer","filter","bezahlungen","gespeicherte","zwischengespeicherte","getZwischengespeicherteBezahlungenForKontokorrent","kk","getKontokorrent","geteilteZahlungen","p","personen","e","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","Array","from","keys","gesamtNenner","reduce","gesamtSumme","g","getBalance","Score","personA","personB","value","Is","balanceList","entries","personId","PersonenBeziehungScoreBewerter","bevorzugteZahlungen","scores","getScores","max","getMax","bevorzugteZahlung","find","empfaengerPersonId","compare","x","y","xScore","yScore","Math","abs","Number","EPSILON","findeBesteZahlung","pA","pB","some","s","AusgleichsZahlung","isCloseTo","epsilon","AusgleichStatus","zahlungsBewerter","angewendeteZahlungen","anwenden","ausgleichsZahlungen","mussZahlungenAnwenden","mussZahlungen","zahlungen","z","bezahlenderStatus","getGleicheAufloesenCandidate","empfaenger","bezahler","closestDiff","Infinity","closestKombination","bezahlerKombination","index","aktDiff","min","gleicheAufloesen","gleichheitErzeugen","moeglicheGleichheitsZahlungen","bezahlender","empfaengerKandidaten","empf","empfaengerKandidat","bezahlender2","best","istAufgeloest","getAusgleich","ausgleichZahlungen","flattenAusgleichZahlungen","concat","moeglicheZahlung","einfacheZahlungKandidaten","einfacheZahlung","teilzahlungKandidaten","teilzahlung","AusgleichNichtMoeglichError","AusgleichService","calc","ausgleichStatus","ausgleichOptions","geforderteZahlungen","KontokorrentGeoeffnet","KontokorrentBezahlungen","KontokorrentSynchronisieren","KontokorrentSynchronisiert","KontokorrentBalanceAktualisiert","KontokorrentNichtGefunden","oeffentlicherName","KontokorrentOeffnen","AusgleichBerechnen","AusgleichBerechnet","ausgleich","storeAdapter","dispatch","action","self","postMessage","msg","cb","upgrade","oldVersion","newVersion","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","objectStoreNames","contains","deleteObjectStore","close","withInitialized","getAll","keySelector","name","toLowerCase","localeCompare","mapped","unwrapped","Promise","resolve","reject","tx","transaction","onerror","err","console","error","oncomplete","objectStore","add","ev","log","preventDefault","stopPropagation","appState","kks","getKontokorrents","kontokorrents","existing","d","delete","newIds","ex","combined","getFromIndex","getAllFromIndex","clear","tokenType","t","lastTimeStamp","durability","store","timestamp","done","accountInfo","bezahlungId","aktion","status","m","accountInfoStore","setAccountInfo","getAccountInfo","clearAccountInfo","getAccessToken","updateAccessTokenIfNewer","apiClient","secret","ok","success","res","getAuthHeader","json","einladungsCode","params","encodeURIComponent","exists","ab","query","notfound","mapAktionen","zeitpunkt","Date","info","Error","anonym","tokenResponse","tokenInfo","expires","parse","google","beschreibungVorschlagActionCreator","resetCache","formatSearchString","replace","sameChars","beschreibungenCache","beschreibungen","eingabe","beschreibung","search","result","trim","r","occurence","formatted","indexOf","score","slice","kontokorrentSyncActionCreator","Gespeichert","Zwischengespeichert","calculateBalance","all","refreshBezahlungen","getLaufendeNummer","addAktionen","refreshKontokorrent","getPerOeffentlichName","setZuletztGesehenerKontokorrentId","kontokorrentSynchronisieren","addEventListener","kontokorrentOeffnen","getVorschlaege","ausgleichRechnen","process","data","catch","internalObjectKeys","hiddenKeys","exports","f","getOwnPropertyNames","O","fails","whitespaces","module","METHOD_NAME","requireObjectCoercible","toString","whitespace","ltrim","RegExp","rtrim","createMethod","TYPE","$this","string","start","end","$","$trim","target","proto","forced","forcedStringTrimMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","__webpack_exports__","chunkIds","fn","priority","notFulfilled","fulfilled","j","every","splice","definition","o","defineProperty","enumerable","chunkId","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}