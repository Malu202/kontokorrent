{"version":3,"sources":["webpack://kontokorrent/./node_modules/comlink/dist/esm/comlink.mjs","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./node_modules/idb/build/esm/wrap-idb-value.js","webpack://kontokorrent/./node_modules/idb/build/esm/index.js","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts"],"names":["proxyMarker","Symbol","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","obj","port1","port2","MessageChannel","expose","deserialize","port","start","createProxy","target","value","serialized","Error","isError","message","name","stack","Object","assign","ep","self","addEventListener","callback","ev","data","id","type","path","argumentList","map","fromWireValue","returnValue","parent","slice","reduce","prop","rawValue","apply","proxy","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","then","wireValue","transferables","toWireValue","postMessage","removeEventListener","closeEndPoint","endpoint","constructor","isMessagePort","close","throwIfProxyReleased","isReleased","isProxyReleased","Proxy","_target","requestResponseMessage","p","toString","length","r","bind","_thisArg","rawArgumentList","last","processArguments","processed","v","arr","Array","prototype","concat","WeakMap","handler","serializedValue","serialize","get","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","l","groupBy","list","key","forEach","item","k","collection","push","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","db","summe","nenner","andere","c","n","kontokorrentId","bezahlungen","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","values","filterBezahlungen","this","getAktionen","kk","getKontokorrent","geteilteZahlungen","personen","e","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","from","keys","gesamtNenner","gesamtSumme","g","erweitern","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","receiver","IDBTransaction","objectStoreNames","objectStore","has","transformCachableValue","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","unwrap","storeNames","tx","call","done","reject","unlisten","complete","error","DOMException","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","IDBRequest","request","promise","success","result","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","oldTraps","KontokorrentsStore","AppStateStore","AktionenStore","KontokorrentSynchronizer","max","cb","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","withInitialized","getAll","keySelector","toLowerCase","localeCompare","tasks","add","all","appState","kks","getKontokorrents","kontokorrents","existing","filter","d","delete","newIds","ex","find","combined","oeffentlicherName","getFromIndex","getAllFromIndex","clear","tokenType","t","lastTimeStamp","durability","timestamp","console","calculateBalance","getLaufendeNummer"],"mappings":"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","file":"ac8c69467dc9345a14c6.bundle.js","sourcesContent":["/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let bezahlungen = filterBezahlungen(aktionen);\n        let kk = await this.db.getKontokorrent(kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return balance;\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { resolve } from \"path\";\nimport { ca } from \"date-fns/locale\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [] } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 3, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AktionenStore, \"readwrite\");\n            let tasks = aktionen.map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            }).map(a => tx.store.add(a));\n            await Promise.all(tasks);\n            await tx.done;\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n}\n\n","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let max = Math.max(...aktionen.map(v => v.laufendeNummer));\n        return max;\n    }\n}","import { expose } from \"comlink\";\nimport { BalanceCalculator } from \"../lib/BalanceCalculator\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { KontokorrentSynchronizer } from \"../lib/KontokorrentSynchronizer\";\n\nconst db = new KontokorrentDatabase();\n\nexport async function calculateBalance(kontokorrentId: string) {\n    return await (new BalanceCalculator(db).calculateBalance(kontokorrentId));\n}\n\nexport async function getLaufendeNummer(kontokorrentId: string) {\n    return await (new KontokorrentSynchronizer(db).getLaufendeNummer(kontokorrentId));\n}\n\nconst exports = {\n    calculateBalance,\n    getLaufendeNummer\n};\nexport type KontokorrentWorkerApi = typeof exports;\nexpose(exports, self);","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}"],"sourceRoot":""}