{"version":3,"file":"404f438280bd3fcf780a.bundle.js","mappings":"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","sources":["webpack://kontokorrent/webpack/runtime/chunk loaded","webpack://kontokorrent/webpack/runtime/startup chunk dependencies","webpack://kontokorrent/./src/lib/AccountType.ts","webpack://kontokorrent/./src/api/postJson.ts","webpack://kontokorrent/./src/api/TokenRenewFailedException.ts","webpack://kontokorrent/./src/api/InteractionRequiredException.ts","webpack://kontokorrent/./src/api/ApiException.ts","webpack://kontokorrent/./src/environment.ts","webpack://kontokorrent/./src/api/NeueBezahlungFailedException.ts","webpack://kontokorrent/./src/api/BezahlungBearbeitenFailedException.ts","webpack://kontokorrent/./src/api/BezahlungLoeschenFailedException.ts","webpack://kontokorrent/./src/api/ApiClient.ts","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/state/State.ts","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/state/actions/BeschreibungVorschlagActionCreator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/state/actions/KontokorrentSyncActionCreator.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/./src/lib/AccountInfoStore.ts","webpack://kontokorrent/./node_modules/core-js/internals/object-get-own-property-names.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim-forced.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim.js","webpack://kontokorrent/./node_modules/core-js/internals/whitespaces.js","webpack://kontokorrent/./node_modules/core-js/modules/es.string.trim.js","webpack://kontokorrent/webpack/bootstrap","webpack://kontokorrent/webpack/runtime/define property getters","webpack://kontokorrent/webpack/runtime/ensure chunk","webpack://kontokorrent/webpack/runtime/get javascript chunk filename","webpack://kontokorrent/webpack/runtime/get mini-css chunk filename","webpack://kontokorrent/webpack/runtime/global","webpack://kontokorrent/webpack/runtime/hasOwnProperty shorthand","webpack://kontokorrent/webpack/runtime/publicPath","webpack://kontokorrent/webpack/runtime/importScripts chunk loading","webpack://kontokorrent/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(820).then(next);\n};","export enum AccountType {\n    google = \"google\",\n    anonym = \"anonym\"\n};\n","export async function postJson(url: string, body: any, token?: string) {\n    let init: RequestInit = {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    };\n    if (token) {\n        init.headers = { ...init.headers, \"Authorization\": `Bearer ${token}` };\n    }\n    return await fetch(url, init);\n}","export class TokenRenewFailedException {\n    constructor(public readonly networkError: boolean) {\n\n    }\n}","export class InteractionRequiredException {\n\n}\n\n","\nexport class ApiException {\n}\n","let API_URL;\nif (__ENVIRONMENT == \"local\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pagesv2\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\n\nexport const environment = {\n    API_URL: API_URL\n};\n","\nexport class NeueBezahlungFailedException {\n}\n\n\n","\nexport class BezahlungBearbeitenFailedException {\n}\n","\nexport class BezahlungLoeschenFailedException {\n}\n","import { postJson } from \"./postJson\";\nimport { AccountType } from \"../lib/AccountType\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentInfo } from \"./KontokorrentInfo\";\nimport { NeuerKontokorrentRequest } from \"./NeuerKontokorrentRequest\";\nimport { TokenRenewFailedException } from \"./TokenRenewFailedException\";\nimport { InteractionRequiredException } from \"./InteractionRequiredException\";\nimport { ApiException } from \"./ApiException\";\nimport { Aktion } from \"./Aktion\";\nimport { environment } from \"../environment\";\nimport { NeueBezahlungRequest } from \"./NeueBezahlungRequest\";\nimport { NeueBezahlungFailedException } from \"./NeueBezahlungFailedException\";\nimport { BezahlungBearbeitenRequest } from \"./BezahlungBearbeitenRequest\";\nimport { BezahlungBearbeitenFailedException } from \"./BezahlungBearbeitenFailedException\";\nimport { BezahlungLoeschenFailedException } from \"./BezahlungLoeschenFailedException\";\n\nconst baseUrl = environment.API_URL;\n\nexport class ApiClient {\n\n    constructor(private accountInfoStore: AccountInfoStore) {\n\n    }\n\n    async neuerBenutzer(id: string, secret: string) {\n        try {\n            let res = await postJson(`${baseUrl}/api/v2/accounts`, { id, secret });\n            if (!res.ok) {\n                return { success: false };\n            }\n            return { success: true };\n        }\n        catch(err) {\n            return { success: false };\n        }\n    }\n\n    async getUserInfo() {\n        let res = await fetch(`${baseUrl}/api/v2/userinfo`, { headers: await this.getAuthHeader() });\n        return await res.json();\n    }\n\n    private async getAuthHeader() {\n        return { \"Authorization\": `Bearer ${await this.getAccessToken()}` };\n    }\n\n    async kontokorrentHinzufuegen(oeffentlicherName: string, einladungsCode: string) {\n        let params = \"\";\n        if (oeffentlicherName) {\n            params = `oeffentlicherName=${encodeURIComponent(oeffentlicherName)}`;\n        }\n        else {\n            params = `einladungsCode=${encodeURIComponent(einladungsCode)}`;\n        }\n        let headers = await this.getAuthHeader();\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents?${params}`, { method: \"PUT\", headers: headers });\n        if (res.status == 404) {\n            return null;\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n    async kontokorrentsAuflisten() {\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents`, { headers: await this.getAuthHeader() });\n        if (!res.ok) {\n            throw new ApiException();\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n\n    async neuerKontokorrent(request: NeuerKontokorrentRequest) {\n        let res = await postJson(`${baseUrl}/api/v2/kontokorrents`, request, await this.getAccessToken());\n        if (res.status == 422) {\n            return { success: false, exists: true };\n        }\n        else if (res.ok) {\n            return { success: true };\n        }\n        return { success: false };\n    }\n\n    async getAktionen(kontokorrentId: string, ab?: number) {\n        let query = ab ? `?ab=${ab}` : \"\";\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen${query}`, { headers: await this.getAuthHeader() });\n        if (res.status == 404) {\n            return {\n                success: false,\n                notfound: true\n            };\n        }\n        else if (res.ok) {\n            let aktionen: Aktion[] = await res.json();\n            return {\n                success: true,\n                aktionen: this.mapAktionen(aktionen)\n            }\n        }\n    }\n\n    private mapAktionen(aktionen : Aktion[]) : Aktion[] {\n        for (let a of aktionen) {\n            if (a.bezahlung) {\n                a.bezahlung.zeitpunkt = new Date(a.bezahlung.zeitpunkt);\n            }\n        }\n        return aktionen;\n    }\n\n    async neueBezahlung(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.hinzufuegenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new NeueBezahlungFailedException();\n    }\n\n    async bezahlungLoeschen(kontokorrentId: string, bezahlungId:string) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.loeschenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify({id:bezahlungId})\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungLoeschenFailedException();\n    }\n\n    async bezahlungBearbeiten(kontokorrentId: string, request: BezahlungBearbeitenRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.bearbeitenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungBearbeitenFailedException();\n    }\n\n\n    private async getAccessToken() {\n        let info = await this.accountInfoStore.get();\n        if (null == info) {\n            throw new Error(\"Keine Account Information gespeichert.\");\n        }\n        if (info.type == AccountType.anonym) {\n            let tokenInfo = await this.accountInfoStore.getAccessToken(\"anonymous\");\n            if (null != tokenInfo) {\n                let { token, expires } = JSON.parse(tokenInfo.value);\n                if (token && expires && expires >= +new Date()) {\n                    return token;\n                }\n            }\n            let tokenResponse;\n            try {\n                let res = await postJson(`${baseUrl}/api/v2/token`, { id: info.id, secret: info.secret });\n                if (!res.ok) {\n                    throw new TokenRenewFailedException(false);\n                }\n                tokenResponse = await res.json();\n            }\n            catch(err) {\n                throw new TokenRenewFailedException(true);\n            }\n            await this.accountInfoStore.updateAccessTokenIfNewer(\"anonymous\", JSON.stringify(tokenResponse), tokenInfo?.timestamp);\n            return tokenResponse.token;\n        }\n        else if (info.type == AccountType.google) {\n            throw new InteractionRequiredException();\n            // let flow = new OAuth2PopupFlow({\n            //     authorizationUri: \"https://accounts.google.com/o/oauth2/v2/auth/.well-known/openid-configuration\",\n            //     clientId: \"82890837151-n0e81vsn3ns2qn1ksh7bdohmnlau468k.apps.googleusercontent.com\",\n            //     redirectUri: \"http://localhost:4200\",\n            //     scope: \"openid\",\n            //     responseType: \"id_token\",\n            //     additionalAuthorizationParameters: { \"login_hint\": info.id },\n            //     accessTokenStorageKey: \"access_token_google\"\n            // });\n            // return await flow.token();\n        }\n        else {\n            throw new Error(`Account Typ ${info.type} unbekannt`);\n        }\n    }\n}","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\nimport { BearbeitungsStatus } from \"./BearbeitungsStatus\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        let mapped = aktionen\n            .map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            });\n        return await this.withInitialized(db => {\n            const unwrapped = unwrap(<IDBPDatabase>db);\n            return new Promise((resolve, reject) => {\n                const tx = unwrapped.transaction(AktionenStore, \"readwrite\");\n                tx.onerror = err => {\n                    console.error(\"addAktionen failed\", err, tx.error);\n                    reject(tx.error);\n                };\n                tx.oncomplete = () => {\n                    resolve();\n                }\n                for (let a of mapped) {\n                    let request = tx.objectStore(AktionenStore).add(a);\n                    request.onerror = ev => {\n                        if (request.error.name == \"ConstraintError\") {\n                            console.log(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} bereits gespeichert.`, ev, request.error);\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        } else {\n                            console.error(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} konnte nicht gespeichert werden.`, ev, request.error);\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return (await db.getAll(NeueBezahlungenStore));\n        });\n    }\n\n    async getBezahlungAktion(kontokorrentId: string, bezahlungId: string): Promise<AktionDbModel> {\n        return await this.withInitialized(async db => {\n            var aktionen = db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            return (await aktionen).find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n        });\n    }\n\n    async getBearbeitungsStatus(kontokorrentId: string, bezahlungId: string): Promise<{ aktion: AktionDbModel, status: BearbeitungsStatus }> {\n        return await this.withInitialized(async db => {\n            let aktionen: AktionDbModel[] = await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            let aktion = aktionen.find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n            if (!aktion) {\n                let neueBezahlungen: NeueBezahlungDbModel[] = await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n                let neueBezahlung = neueBezahlungen.find(a => a.id == bezahlungId);\n                if (neueBezahlung) {\n                    return { aktion: null, status: BearbeitungsStatus.Zwischengespeichert };\n                }\n                return { aktion: null, status: BearbeitungsStatus.NichtGefunden };\n            }\n            let bearbeitendeAktion = aktionen.find(a => a.bearbeiteteBezahlungId == bezahlungId);\n            if (null != bearbeitendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Bearbeitet };\n            }\n            let loeschendeAktion = aktionen.find(a => a.geloeschteBezahlungId == bezahlungId);\n            if (null != loeschendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Geloescht };\n            }\n            return { aktion: aktion, status: BearbeitungsStatus.Bearbeitbar };\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","import { AccountInfo } from \"../lib/AccountInfo\";\nimport { BearbeitungsStatus } from \"../lib/BearbeitungsStatus\";\n\nexport interface AccountState {\n    accountCreated: boolean,\n    accountCreating: boolean,\n    accountCreationFailed: boolean\n    loginExpired: boolean;\n    accountInfo: AccountInfo\n}\n\nexport interface KontokorrentsState {\n    kontokorrents: { [id: string]: KontokorrentState };\n    hinzufuegen: boolean;\n    listeLaden: boolean;\n    hinzufuegenFailed: {\n        kontokorrentNotFound: boolean\n    }\n    creating: boolean;\n    creationFailed: { exists: boolean };\n    activeKontokorrentId: string;\n}\n\nexport interface Person {\n    name: string;\n    id: string;\n    balance: number;\n}\n\nexport enum BezahlungStatus {\n    Zwischengespeichert = \"zwischengespeichert\",\n    Speichern = \"speichern\",\n    Gespeichert = \"gespeichert\"\n}\n\nexport interface Bezahlung {\n    id: string;\n    zeitpunkt: Date;\n    bezahlendePersonId: string;\n    empfaengerIds: string[];\n    wert: number;\n    beschreibung: string;\n    status: BezahlungStatus\n}\n\nexport const enum RequestStatus {\n    InProgress,\n    Success,\n    Failed\n}\n\nexport interface AngezeigteBezahlungState {\n    bearbeitungsStatus: BearbeitungsStatus;\n    updateStatus?: RequestStatus;\n    deleteStatus?: RequestStatus;\n}\n\nexport interface KontokorrentState {\n    id: string;\n    name: string;\n    personen: Person[];\n    bezahlungen: Bezahlung[];\n    synchronisieren: boolean;\n    bezahlungAnlegen: RequestStatus;\n    angezeigteBezahlung: { [id: string]: AngezeigteBezahlungState }\n}\n\nexport interface BeschreibungVorschlagState {\n    kontokorrentId: string;\n    vorschlaege: string[];\n}\n\nexport interface State {\n    account: AccountState\n    kontokorrents: KontokorrentsState;\n    beschreibungVorschlaege: BeschreibungVorschlagState;\n}\n","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { Store } from \"../lib/Store\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { ActionNames } from \"./ActionNames\";\nimport { Action } from \"../lib/Action\";\nimport { groupBy } from \"../../utils/groupBy\";\n\nexport class BeschreibungsVorschlaege implements Action {\n    readonly type = ActionNames.BeschreibungsVorschlaege;\n    constructor(public kontokorrentId: string, public vorschlaege: string[]) {\n\n    }\n}\n\nexport type BeschreibungVorschlagActions =\n    | BeschreibungsVorschlaege;\n\nexport class BeschreibungVorschlagActionCreator {\n    private beschreibungenCache: { kontokorrentId: string, beschreibungen: { search: string, result: string, occurence: number }[] };\n    constructor(private db: KontokorrentDatabase, private store: Store) {\n        this.resetCache();\n    }\n\n\n    private formatSearchString(s: string) {\n        return s.toLowerCase().replace(/\\s|-/g, \"\");\n    }\n\n    private sameChars(s: string, d: string) {\n        let i;\n        for (i = 0; i < Math.min(s.length, d.length); i++) {\n            if (s[i] != d[i]) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    resetCache() {\n        this.beschreibungenCache = { kontokorrentId: null, beschreibungen: [] };\n    }\n\n    async getVorschlaege(kontokorrentId: string, eingabe: string) {\n        if (this.beschreibungenCache.kontokorrentId != kontokorrentId) {\n            let aktionen = await this.db.getAktionen(kontokorrentId);\n            let beschreibungen = aktionen.filter(a => null != a.bezahlung?.beschreibung).map(a => {\n                return { search: this.formatSearchString(a.bezahlung.beschreibung), result: a.bezahlung.beschreibung.trim() }\n            });\n            this.beschreibungenCache.kontokorrentId = kontokorrentId;\n            let map = groupBy(beschreibungen, \"search\");\n            this.beschreibungenCache.beschreibungen = Array.from(map.entries()).map(([search, r]) => {\n\n                return {\n                    search,\n                    result: r[0].result,\n                    occurence: r.length\n                };\n            }).sort((a, b) => b.occurence - a.occurence);\n        }\n        if (eingabe) {\n            let formatted = this.formatSearchString(eingabe);\n            let vorschlaege = this.beschreibungenCache.beschreibungen\n                .filter(({ search }) => search.indexOf(formatted) > -1)\n                .map(({ search, result }) => {\n                    return { result, score: this.sameChars(formatted, search) }\n                }).sort((a, b) => b.score - a.score);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege.map(b => b.result)));\n        }\n        else {\n            let vorschlaege = this.beschreibungenCache.beschreibungen.slice(0, 10).map(b => b.result);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege));\n        }\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let sorted = aktionen.map(v => v.laufendeNummer).sort((a, b) => a - b);\n        let i: number;\n        for (i = 0; i < sorted.length - 1; i++) {\n            if (sorted[i] + 1 !== sorted[i + 1]) {\n                break;\n            }\n        }\n        return sorted[i];\n    }\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\ntype Bezahlung = { empfaengerIds: string[], bezahlendePersonId: string, wert: number };\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let gespeicherte: Bezahlung[] = filterBezahlungen(aktionen);\n        let zwischengespeicherte: Bezahlung[] = await this.db.getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId);\n        let bezahlungen = [...zwischengespeicherte, ...gespeicherte];\n        let kk = await this.db.getKontokorrent(kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return balance;\n    }\n}","import { Store } from \"../lib/Store\";\nimport { ApiClient } from \"../../api/ApiClient\";\nimport { Action } from \"../lib/Action\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { Bezahlung, BezahlungStatus } from \"../State\";\nimport { filterBezahlungen } from \"../../lib/filterBezahlungen\";\nimport { ActionNames } from \"./ActionNames\";\nimport { KontokorrentSynchronizer } from \"../../lib/KontokorrentSynchronizer\";\nimport { BalanceCalculator } from \"../../lib/BalanceCalculator\";\nimport { KontokorrentBalance } from \"../../lib/KontokorrentBalance\";\n\nexport class KontokorrentGeoeffnet implements Action {\n    readonly type = ActionNames.KontokorrentGeoeffnet;\n    constructor(public id: string) {\n\n    }\n}\n\nexport class KontokorrentBezahlungen implements Action {\n    readonly type = ActionNames.KontokorrentBezahlungen;\n    constructor(public kontokorrentId: string, public bezahlungen: Bezahlung[]) {\n\n    }\n}\n\nexport class KontokorrentSynchronisieren implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisieren;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentSynchronisiert implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisiert;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentBalanceAktualisiert implements Action {\n    readonly type = ActionNames.KontokorrentBalanceAktualisiert;\n    constructor(public kontokorrentId: string, public balance: KontokorrentBalance) {\n\n    }\n}\n\nexport type KontokorrentSyncActions =\n    | KontokorrentGeoeffnet\n    | KontokorrentBezahlungen\n    | KontokorrentSynchronisieren\n    | KontokorrentSynchronisiert\n    | KontokorrentBalanceAktualisiert;\n\nexport class KontokorrentSyncActionCreator {\n\n    constructor(private store: Store,\n        private apiClient: ApiClient,\n        private db: KontokorrentDatabase) {\n\n    }\n    private async refreshBezahlungen(id: string) {\n        let aktionen = filterBezahlungen(await this.db.getAktionen(id)).map(b => {\n            return {\n                ...b,\n                status: BezahlungStatus.Gespeichert\n            };\n        });\n        let zwischengespeicherte = (await this.db.getZwischengespeicherteBezahlungenForKontokorrent(id)).map(b => {\n            let x: Bezahlung = {\n                status: BezahlungStatus.Zwischengespeichert,\n                beschreibung: b.beschreibung,\n                bezahlendePersonId: b.bezahlendePersonId,\n                empfaengerIds: b.empfaengerIds,\n                id: b.id,\n                wert: b.wert,\n                zeitpunkt: b.zeitpunkt\n            };\n            return x;\n        }).filter(b => !aktionen.some(a => a.id == b.id));\n        this.store.dispatch(new KontokorrentBezahlungen(id, [...aktionen, ...zwischengespeicherte]));\n    }\n\n    private async calculateBalance(id: string) {\n        let balance = await (new BalanceCalculator(this.db).calculateBalance(id));;\n        this.store.dispatch(new KontokorrentBalanceAktualisiert(id, balance));\n    }\n\n    private async refreshKontokorrent(id: string) {\n        await Promise.all([this.refreshBezahlungen(id), this.calculateBalance(id)]);\n    }\n\n    private async kontokorrentSynchronisieren(id: string) {\n        this.store.dispatch(new KontokorrentSynchronisieren(id));\n        let laufendeNummer = await (new KontokorrentSynchronizer(this.db).getLaufendeNummer(id));\n        let res = await this.apiClient.getAktionen(id, laufendeNummer);\n        if (res.success) {\n            await this.db.addAktionen(id, res.aktionen);\n            if (res.aktionen.length > 0) {\n                await this.refreshKontokorrent(id);\n            }\n        }\n        this.store.dispatch(new KontokorrentSynchronisiert(id));\n    }\n\n\n\n    async kontokorrentOeffnen(id: string) {\n        let kk = await this.db.getKontokorrent(id);\n        if (null != kk) {\n            this.store.dispatch(new KontokorrentGeoeffnet(id));\n            await Promise.all([this.db.setZuletztGesehenerKontokorrentId(id), this.refreshKontokorrent(id)]);\n            await this.kontokorrentSynchronisieren(id);\n        }\n    }\n}","import { ApiClient } from \"../api/ApiClient\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { BeschreibungVorschlagActionCreator } from \"../state/actions/BeschreibungVorschlagActionCreator\";\nimport { KontokorrentSyncActionCreator } from \"../state/actions/KontokorrentSyncActionCreator\";\nimport { Action } from \"../state/lib/Action\";\n\nlet storeAdapter = {\n    dispatch(action: Action): void {\n        self.postMessage({ type: \"statedispatch\", msg: action });\n    }\n}\n\nexport const enum WorkerMessageType {\n    KontokorrentOeffnen,\n    GetBeschreibungVorschlaege,\n    ResetBeschreibungenCache\n}\n\nexport interface KontokorrentOeffnenMessage {\n    type: WorkerMessageType.KontokorrentOeffnen;\n    kontokorrentId: string;\n}\n\nexport interface GetBeschreibungVorschlaegeMessage {\n    type: WorkerMessageType.GetBeschreibungVorschlaege;\n    kontokorrentId: string;\n    eingabe: string;\n}\nexport interface ResetBeschreibungenCacheMessage {\n    type: WorkerMessageType.ResetBeschreibungenCache;\n}\n\ntype WorkerMessage = KontokorrentOeffnenMessage\n    | GetBeschreibungVorschlaegeMessage\n    | ResetBeschreibungenCacheMessage;\n\nconst db = new KontokorrentDatabase();\nconst accountInfoStore = new AccountInfoStore(db);\nconst apiClient = new ApiClient(accountInfoStore);\nconst beschreibungVorschlagActionCreator = new BeschreibungVorschlagActionCreator(db, storeAdapter);\nconst kontokorrentSyncActionCreator = new KontokorrentSyncActionCreator(storeAdapter, apiClient, db);\n\nasync function process(msg: WorkerMessage) {\n    switch (msg.type) {\n        case WorkerMessageType.KontokorrentOeffnen:\n            await kontokorrentSyncActionCreator.kontokorrentOeffnen(msg.kontokorrentId);\n            break;\n        case WorkerMessageType.GetBeschreibungVorschlaege:\n            await beschreibungVorschlagActionCreator.getVorschlaege(msg.kontokorrentId, msg.eingabe);\n            break;\n        case WorkerMessageType.ResetBeschreibungenCache:\n            beschreibungVorschlagActionCreator.resetCache();\n            break;\n    }\n}\n\nself.addEventListener(\"message\", e => {\n    let msg: WorkerMessage = e.data;\n    process(msg).catch(err => console.error(err));\n});","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","import { AccountInfo } from \"./AccountInfo\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class AccountInfoStore {\n    constructor(private db: KontokorrentDatabase) {\n\n    }\n\n    async set(accountInfo: AccountInfo): Promise<void> {\n        await this.db.setAccountInfo(accountInfo);\n    }\n    async get(): Promise<AccountInfo> {\n        return await this.db.getAccountInfo();\n    }\n    async clear(): Promise<void> {\n        await this.db.clearAccountInfo();\n    }\n\n    async getAccessToken(tokenType: \"google\" | \"anonymous\"): Promise<{ timestamp: number, value: string }> {\n        return await this.db.getAccessToken(tokenType);\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number) {\n        return await this.db.updateAccessTokenIfNewer(tokenType, value, lastTimeStamp);\n    }\n}\n\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","var fails = require('../internals/fails');\nvar whitespaces = require('../internals/whitespaces');\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","'use strict';\nvar $ = require('../internals/export');\nvar $trim = require('../internals/string-trim').trim;\nvar forcedStringTrimMethod = require('../internals/string-trim-forced');\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [820], function() { return __webpack_require__(1712); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + \"0cdd927a1d4532914d47\" + \".bundle.js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/v2/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t837: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkontokorrent\"] = self[\"webpackChunkkontokorrent\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","AccountType","async","postJson","url","body","token","init","method","headers","JSON","stringify","fetch","TokenRenewFailedException","constructor","networkError","InteractionRequiredException","ApiException","API_URL","environment","NeueBezahlungFailedException","BezahlungBearbeitenFailedException","BezahlungLoeschenFailedException","baseUrl","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","BezahlungStatus","groupBy","list","key","map","Map","forEach","item","k","collection","get","push","set","BeschreibungsVorschlaege","kontokorrentId","vorschlaege","type","filterBezahlungen","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","id","Object","values","KontokorrentSynchronizer","db","i","sorted","this","getAktionen","v","length","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","erweitern","summe","nenner","andere","c","n","gespeicherte","bezahlungen","getZwischengespeicherteBezahlungenForKontokorrent","kk","getKontokorrent","geteilteZahlungen","p","personen","e","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","Array","from","keys","gesamtNenner","reduce","gesamtSumme","g","KontokorrentGeoeffnet","KontokorrentBezahlungen","KontokorrentSynchronisieren","KontokorrentSynchronisiert","KontokorrentBalanceAktualisiert","storeAdapter","dispatch","action","self","postMessage","msg","cb","upgrade","oldVersion","newVersion","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","objectStoreNames","contains","deleteObjectStore","close","withInitialized","getAll","keySelector","name","toLowerCase","localeCompare","mapped","unwrapped","Promise","resolve","reject","tx","transaction","onerror","err","console","error","oncomplete","request","objectStore","add","ev","log","preventDefault","stopPropagation","appState","kks","getKontokorrents","kontokorrents","existing","filter","some","d","delete","newIds","ex","find","combined","oeffentlicherName","getFromIndex","getAllFromIndex","clear","tokenType","t","value","lastTimeStamp","durability","store","timestamp","done","accountInfo","bezahlungId","aktion","status","m","accountInfoStore","setAccountInfo","getAccountInfo","clearAccountInfo","getAccessToken","updateAccessTokenIfNewer","apiClient","secret","ok","success","res","getAuthHeader","json","einladungsCode","params","encodeURIComponent","exists","ab","query","notfound","mapAktionen","zeitpunkt","Date","info","Error","anonym","tokenResponse","tokenInfo","expires","parse","google","beschreibungVorschlagActionCreator","resetCache","formatSearchString","s","replace","sameChars","Math","min","beschreibungenCache","beschreibungen","eingabe","beschreibung","search","result","trim","entries","r","occurence","formatted","indexOf","score","slice","kontokorrentSyncActionCreator","Gespeichert","zwischengespeicherte","Zwischengespeichert","calculateBalance","all","refreshBezahlungen","getLaufendeNummer","addAktionen","refreshKontokorrent","setZuletztGesehenerKontokorrentId","kontokorrentSynchronisieren","addEventListener","kontokorrentOeffnen","getVorschlaege","process","data","catch","internalObjectKeys","hiddenKeys","concat","exports","f","getOwnPropertyNames","O","fails","whitespaces","module","METHOD_NAME","requireObjectCoercible","toString","whitespace","ltrim","RegExp","rtrim","createMethod","TYPE","$this","string","start","end","$","$trim","target","proto","forced","forcedStringTrimMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","x","__webpack_exports__","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","definition","o","defineProperty","enumerable","chunkId","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}