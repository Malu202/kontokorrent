{"version":3,"sources":["webpack://kontokorrent/./src/api/postJson.ts","webpack://kontokorrent/./src/lib/AccountType.ts","webpack://kontokorrent/./src/api/TokenRenewFailedException.ts","webpack://kontokorrent/./src/api/InteractionRequiredException.ts","webpack://kontokorrent/./src/api/ApiException.ts","webpack://kontokorrent/./src/environment.ts","webpack://kontokorrent/./src/api/NeueBezahlungFailedException.ts","webpack://kontokorrent/./src/api/ApiClient.ts","webpack://kontokorrent/./src/lib/AccountInfoStore.ts","webpack://kontokorrent/./node_modules/idb/build/esm/wrap-idb-value.js","webpack://kontokorrent/./node_modules/idb/build/esm/index.js","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/./src/lib/NeueBezahlungService.ts","webpack://kontokorrent/./src/state/actions/ServiceWorkerActions.ts","webpack://kontokorrent/./src/sw.constants.ts","webpack://kontokorrent/./src/sw.ts"],"names":["async","postJson","url","body","token","init","method","headers","JSON","stringify","fetch","AccountType","TokenRenewFailedException","networkError","InteractionRequiredException","ApiException","API_URL","environment","NeueBezahlungFailedException","baseUrl","ApiClient","accountInfoStore","id","secret","ok","success","res","this","getAuthHeader","json","getAccessToken","oeffentlicherName","einladungsCode","params","encodeURIComponent","status","request","exists","kontokorrentId","ab","query","notfound","aktionen","mapAktionen","a","bezahlung","zeitpunkt","Date","aktion","info","get","Error","type","anonym","tokenResponse","tokenInfo","expires","parse","value","updateAccessTokenIfNewer","timestamp","google","AccountInfoStore","db","accountInfo","setAccountInfo","getAccountInfo","clearAccountInfo","tokenType","lastTimeStamp","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","set","has","transformCachableValue","func","IDBDatabase","prototype","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","storeNames","tx","call","sort","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","object","IDBObjectStore","IDBIndex","some","c","Proxy","IDBRequest","promise","result","then","catch","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","storeName","store","index","shift","returnVal","oldTraps","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","KontokorrentDatabase","cb","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","contains","deleteObjectStore","close","withInitialized","collection","getAll","keySelector","k","b","toLowerCase","localeCompare","length","existing","neueAktionen","filter","e","laufendeNummer","map","v","add","appState","kks","getKontokorrents","kontokorrents","d","delete","newIds","ex","find","push","combined","personen","kk","getFromIndex","getAllFromIndex","clear","t","durability","console","m","NeueBezahlungService","apiClient","neueBezahlung","addAktionen","ServiceWorkerBezahlungAnlegen","bezahlungId","ServiceWorkerBezahlungAngelegt","cacheName","dispatchToClients","msg","clients","self","matchAll","client","postMessage","cacheAssets","asset","__WB_MANIFEST","waitUntil","caches","cache","addAll","keys","cacheNames","all","thisCacheName","mode","respondWith","match","response","BackgroundSyncService","neueBezahlungenService","zwischengespeicherte","getZwischengespeicherteBezahlungen","z","bezahlungAnlegen","zwischengespeicherteBezahlungErledigt","err","tag","neueBezahlungService","backgroundSyncService","zwischengespeicherteZahlungenAnlegen"],"mappings":"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","file":"sw.js","sourceRoot":"","sourcesContent":["export async function postJson(url: string, body: any, token?: string) {\n    let init: RequestInit = {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    };\n    if (token) {\n        init.headers = { ...init.headers, \"Authorization\": `Bearer ${token}` };\n    }\n    return await fetch(url, init);\n}","export enum AccountType {\n    google = \"google\",\n    anonym = \"anonym\"\n};\n","export class TokenRenewFailedException {\n    constructor(public readonly networkError: boolean) {\n\n    }\n}","export class InteractionRequiredException {\n\n}\n\n","\nexport class ApiException {\n}\n","let API_URL;\nif (__ENVIRONMENT == \"local\") {\n    API_URL = \"https://kontokorrent-v2.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pagesv2\") {\n    API_URL = \"https://kontokorrent-v2.azurewebsites.net\";\n}\nelse {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\n\nexport const environment = {\n    API_URL: API_URL\n};\n","\nexport class NeueBezahlungFailedException {\n}\n","import { postJson } from \"./postJson\";\nimport { AccountType } from \"../lib/AccountType\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentInfo } from \"./KontokorrentInfo\";\nimport { NeuerKontokorrentRequest } from \"./NeuerKontokorrentRequest\";\nimport { TokenRenewFailedException } from \"./TokenRenewFailedException\";\nimport { InteractionRequiredException } from \"./InteractionRequiredException\";\nimport { ApiException } from \"./ApiException\";\nimport { Aktion } from \"./Aktion\";\nimport { environment } from \"../environment\";\nimport { NeueBezahlungRequest } from \"./NeueBezahlungRequest\";\nimport { rejects } from \"assert\";\nimport { NeueBezahlungFailedException } from \"./NeueBezahlungFailedException\";\n\nconst baseUrl = environment.API_URL;\n\nexport class ApiClient {\n\n    constructor(private accountInfoStore: AccountInfoStore) {\n\n    }\n\n    async neuerBenutzer(id: string, secret: string) {\n        try {\n            let res = await postJson(`${baseUrl}/api/v2/accounts`, { id, secret });\n            if (!res.ok) {\n                return { success: false };\n            }\n            return { success: true };\n        }\n        catch {\n            return { success: false };\n        }\n    }\n\n    async getUserInfo() {\n        let res = await fetch(`${baseUrl}/api/v2/userinfo`, { headers: await this.getAuthHeader() });\n        return await res.json();\n    }\n\n    private async getAuthHeader() {\n        return { \"Authorization\": `Bearer ${await this.getAccessToken()}` };\n    }\n\n    async kontokorrentHinzufuegen(oeffentlicherName: string, einladungsCode: string) {\n        let params = \"\";\n        if (oeffentlicherName) {\n            params = `oeffentlicherName=${encodeURIComponent(oeffentlicherName)}`;\n        }\n        else {\n            params = `einladungsCode=${encodeURIComponent(einladungsCode)}`;\n        }\n        let headers = await this.getAuthHeader();\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents?${params}`, { method: \"PUT\", headers: headers });\n        if (res.status == 404) {\n            return null;\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n    async kontokorrentsAuflisten() {\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents`, { headers: await this.getAuthHeader() });\n        if (!res.ok) {\n            throw new ApiException();\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n\n    async neuerKontokorrent(request: NeuerKontokorrentRequest) {\n        let res = await postJson(`${baseUrl}/api/v2/kontokorrents`, request, await this.getAccessToken());\n        if (res.status == 422) {\n            return { success: false, exists: true };\n        }\n        else if (res.ok) {\n            return { success: true };\n        }\n        return { success: false };\n    }\n\n    async getAktionen(kontokorrentId: string, ab?: number) {\n        let query = ab ? `?ab=${ab}` : \"\";\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen${query}`, { headers: await this.getAuthHeader() });\n        if (res.status == 404) {\n            return {\n                success: false,\n                notfound: true\n            };\n        }\n        else if (res.ok) {\n            let aktionen: Aktion[] = await res.json();\n            return {\n                success: true,\n                aktionen: this.mapAktionen(aktionen)\n            }\n        }\n    }\n\n    private mapAktionen(aktionen : Aktion[]) : Aktion[] {\n        for (let a of aktionen) {\n            if (a.bezahlung) {\n                a.bezahlung.zeitpunkt = new Date(a.bezahlung.zeitpunkt);\n            }\n        }\n        return aktionen;\n    }\n\n    async neueBezahlung(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.hinzufuegenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new NeueBezahlungFailedException();\n    }\n\n\n    private async getAccessToken() {\n        let info = await this.accountInfoStore.get();\n        if (null == info) {\n            throw new Error(\"Keine Account Information gespeichert.\");\n        }\n        if (info.type == AccountType.anonym) {\n            let tokenInfo = await this.accountInfoStore.getAccessToken(\"anonymous\");\n            if (null != tokenInfo) {\n                let { token, expires } = JSON.parse(tokenInfo.value);\n                if (token && expires && expires >= +new Date()) {\n                    return token;\n                }\n            }\n            let tokenResponse;\n            try {\n                let res = await postJson(`${baseUrl}/api/v2/token`, { id: info.id, secret: info.secret });\n                if (!res.ok) {\n                    throw new TokenRenewFailedException(false);\n                }\n                tokenResponse = await res.json();\n            }\n            catch {\n                throw new TokenRenewFailedException(true);\n            }\n            await this.accountInfoStore.updateAccessTokenIfNewer(\"anonymous\", JSON.stringify(tokenResponse), tokenInfo?.timestamp);\n            return tokenResponse.token;\n        }\n        else if (info.type == AccountType.google) {\n            throw new InteractionRequiredException();\n            // let flow = new OAuth2PopupFlow({\n            //     authorizationUri: \"https://accounts.google.com/o/oauth2/v2/auth/.well-known/openid-configuration\",\n            //     clientId: \"82890837151-n0e81vsn3ns2qn1ksh7bdohmnlau468k.apps.googleusercontent.com\",\n            //     redirectUri: \"http://localhost:4200\",\n            //     scope: \"openid\",\n            //     responseType: \"id_token\",\n            //     additionalAuthorizationParameters: { \"login_hint\": info.id },\n            //     accessTokenStorageKey: \"access_token_google\"\n            // });\n            // return await flow.token();\n        }\n        else {\n            throw new Error(`Account Typ ${info.type} unbekannt`);\n        }\n    }\n}","import { AccountInfo } from \"./AccountInfo\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class AccountInfoStore {\n    constructor(private db: KontokorrentDatabase) {\n\n    }\n\n    async set(accountInfo: AccountInfo): Promise<void> {\n        await this.db.setAccountInfo(accountInfo);\n    }\n    async get(): Promise<AccountInfo> {\n        return await this.db.getAccountInfo();\n    }\n    async clear(): Promise<void> {\n        await this.db.clearAccountInfo();\n    }\n\n    async getAccessToken(tokenType: \"google\" | \"anonymous\"): Promise<{ timestamp: number, value: string }> {\n        return await this.db.getAccessToken(tokenType);\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number) {\n        return await this.db.updateAccessTokenIfNewer(tokenType, value, lastTimeStamp);\n    }\n}\n\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AktionenStore, \"readwrite\");\n            let existing = await tx.store.index(\"kontokorrentId\").getAll(id);\n            let neueAktionen = aktionen\n                .filter(a => !existing.some(e => a.laufendeNummer == e.laufendeNummer))\n                .map(v => {\n                    let a: AktionDbModel = {\n                        ...v,\n                        kontokorrentId: id\n                    };\n                    return a;\n                });\n            for (let a of neueAktionen) {\n                await tx.store.add(a);\n            }\n            await tx.done;\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return db.getAll(NeueBezahlungenStore);\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","import { ApiClient } from \"../api/ApiClient\";\nimport { NeueBezahlungRequest } from \"../api/NeueBezahlungRequest\";\nimport { ServiceLocator } from \"../ServiceLocator\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class NeueBezahlungService {\n    constructor(private apiClient: ApiClient,\n        private db: KontokorrentDatabase) {\n    }\n\n    async bezahlungAnlegen(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let aktion = await this.apiClient.neueBezahlung(kontokorrentId, request);\n        this.db.addAktionen(kontokorrentId, [aktion]);\n        return aktion;\n    }\n}\n\nexport function neueBezahlungServiceFactory(serviceLocator: ServiceLocator) {\n    return serviceLocator.get(\"NeueBezahlungService\",\n        serviceLocator => new NeueBezahlungService(serviceLocator.apiClient,\n            serviceLocator.db));\n}","import { ActionNames } from \"./ActionNames\";\nimport { Action } from \"../lib/Action\";\n\nexport class ServiceWorkerBezahlungAnlegen implements Action {\n    readonly type = ActionNames.ServiceWorkerBezahlungAnlegen;\n    constructor(public kontokorrentId: string, public bezahlungId: string) {\n\n    }\n}\n\nexport class ServiceWorkerBezahlungAngelegt implements Action {\n    readonly type = ActionNames.ServiceWorkerBezahlungAngelegt;\n    constructor(public kontokorrentId: string, public bezahlungId: string) {\n\n    }\n}\n\nexport type ServiceWorkerActions =\n    | ServiceWorkerBezahlungAngelegt\n    | ServiceWorkerBezahlungAnlegen;","export const NeueBezahlungBackgroundSyncTag = \"NeueBezahlungBackgroundSync\";","import { ApiClient } from \"./api/ApiClient\";\nimport { AccountInfoStore } from \"./lib/AccountInfoStore\";\nimport { KontokorrentDatabase } from \"./lib/KontokorrentDatabase\";\nimport { NeueBezahlungService } from \"./lib/NeueBezahlungService\";\nimport { ServiceWorkerActions, ServiceWorkerBezahlungAngelegt, ServiceWorkerBezahlungAnlegen } from \"./state/actions/ServiceWorkerActions\";\nimport { NeueBezahlungBackgroundSyncTag } from \"./sw.constants\";\n\nexport default null;\ndeclare var self: ServiceWorkerGlobalScope;\ndeclare global {\n    interface WorkerGlobalScope {\n        __WB_MANIFEST: Array<{ revision: null, url: string }>;\n    }\n}\n\nconst cacheName = \"v8\";\n\nself.addEventListener(\"install\", function (event) {\n    const cacheAssets = [\n        \"https://fonts.googleapis.com/icon?family=Material+Icons\",\n        \"https://fonts.googleapis.com/css?family=Roboto:300,400,500&display=swap\"];\n    for (let asset of self.__WB_MANIFEST.map(v => v.url)) {\n        cacheAssets.push(asset);\n    }\n    event.waitUntil(\n        caches.open(cacheName)\n            .then(function (cache) {\n                return cache.addAll(cacheAssets);\n            })\n    );\n});\n\nself.addEventListener(\"activate\", event => {\n    event.waitUntil(\n        caches.keys().then(function (cacheNames) {\n            return Promise.all(cacheNames.map(function (thisCacheName) {\n                if (thisCacheName !== cacheName) {\n                    return caches.delete(thisCacheName);\n                }\n            }));\n        }));\n})\n\n\nself.addEventListener(\"fetch\", function (event) {\n    if (event.request.mode === \"navigate\") {\n        if (event.request.method !== \"GET\") {\n            return;\n        }\n        event.respondWith(caches.match(\"index.html\", { cacheName: cacheName }).then(response => {\n            return response || fetch(event.request);\n        }));\n        return;\n    }\n    event.respondWith(\n        caches.match(event.request).then(function (response) {\n            return response || fetch(event.request);\n        })\n    );\n});\n\nasync function dispatchToClients(msg: ServiceWorkerActions) {\n    const clients = await self.clients.matchAll();\n    for (const client of clients) {\n        client.postMessage({ type: \"statedispatch\", msg });\n    }\n}\n\nclass BackgroundSyncService {\n    constructor(private db: KontokorrentDatabase, private neueBezahlungenService: NeueBezahlungService) {\n\n    }\n\n    async zwischengespeicherteZahlungenAnlegen() {\n        let zwischengespeicherte = await this.db.getZwischengespeicherteBezahlungen();\n        for (let z of zwischengespeicherte) {\n            await dispatchToClients(new ServiceWorkerBezahlungAnlegen(z.kontokorrentId, z.id));\n            try {\n                let res = await this.neueBezahlungenService.bezahlungAnlegen(z.kontokorrentId, z);\n                await this.db.zwischengespeicherteBezahlungErledigt(res.bezahlung.id);\n                await dispatchToClients(new ServiceWorkerBezahlungAngelegt(z.kontokorrentId, z.id));\n            }\n            catch (err) {\n                console.error(\"Fehler beim Anlegen der Zahlung\", err);\n            }\n        }\n    }\n}\n\nself.addEventListener(\"sync\", function (event) {\n    if (event.tag == NeueBezahlungBackgroundSyncTag) {\n        event.waitUntil((async () => {\n            let db = new KontokorrentDatabase();\n            let accountInfoStore = new AccountInfoStore(db);\n            let apiClient = new ApiClient(accountInfoStore);\n            let neueBezahlungService = new NeueBezahlungService(apiClient, db);\n            let backgroundSyncService = new BackgroundSyncService(db, neueBezahlungService);\n            await backgroundSyncService.zwischengespeicherteZahlungenAnlegen();\n        })());\n    }\n});"]}