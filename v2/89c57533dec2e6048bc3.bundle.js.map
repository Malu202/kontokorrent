{"version":3,"sources":["webpack://kontokorrent/webpack/runtime/startup chunk dependencies","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/webpack/bootstrap","webpack://kontokorrent/webpack/runtime/define property getters","webpack://kontokorrent/webpack/runtime/ensure chunk","webpack://kontokorrent/webpack/runtime/get javascript chunk filename","webpack://kontokorrent/webpack/runtime/get mini-css chunk filename","webpack://kontokorrent/webpack/runtime/hasOwnProperty shorthand","webpack://kontokorrent/webpack/runtime/publicPath","webpack://kontokorrent/webpack/runtime/importScripts chunk loading","webpack://kontokorrent/webpack/startup"],"names":["next","groupBy","list","key","map","Map","forEach","item","k","collection","get","push","set","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","db","summe","nenner","andere","c","n","kontokorrentId","gespeicherte","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","id","Object","values","filterBezahlungen","this","getAktionen","bezahlungen","getZwischengespeicherteBezahlungenForKontokorrent","kk","getKontokorrent","geteilteZahlungen","p","personen","e","empfaengerIds","length","bezahlendePersonId","balance","gruppen","alleNenner","Array","from","keys","gesamtNenner","reduce","gesamtSumme","g","erweitern","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","KontokorrentSynchronizer","i","sorted","v","cb","oldVersion","newVersion","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","objectStoreNames","contains","deleteObjectStore","close","withInitialized","getAll","keySelector","name","toLowerCase","localeCompare","mapped","unwrapped","Promise","resolve","reject","tx","transaction","onerror","err","console","error","oncomplete","request","objectStore","add","ev","log","preventDefault","stopPropagation","appState","kks","getKontokorrents","kontokorrents","existing","filter","some","d","delete","newIds","ex","find","combined","oeffentlicherName","getFromIndex","getAllFromIndex","clear","tokenType","t","type","value","lastTimeStamp","durability","store","timestamp","done","accountInfo","m","calculateBalance","getLaufendeNummer","self","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","x","definition","o","defineProperty","enumerable","f","chunkId","all","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","call","then","installedChunks","948","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","data","chunkIds","moreModules","runtime","pop"],"mappings":"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","file":"89c57533dec2e6048bc3.bundle.js","sourcesContent":["var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(803).then(next);\n};","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\ntype Bezahlung = { empfaengerIds: string[], bezahlendePersonId: string, wert: number };\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let gespeicherte: Bezahlung[] = filterBezahlungen(aktionen);\n        let zwischengespeicherte: Bezahlung[] = await this.db.getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId);\n        let bezahlungen = [...zwischengespeicherte, ...gespeicherte];\n        let kk = await this.db.getKontokorrent(kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return balance;\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        let mapped = aktionen\n            .map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            });\n        return await this.withInitialized(db => {\n            const unwrapped = unwrap(<IDBPDatabase>db);\n            return new Promise((resolve, reject) => {\n                const tx = unwrapped.transaction(AktionenStore, \"readwrite\");\n                tx.onerror = err => {\n                    console.error(\"addAktionen failed\", err, tx.error);\n                    reject(tx.error);\n                };\n                tx.oncomplete = () => {\n                    resolve();\n                }\n                for (let a of mapped) {\n                    let request = tx.objectStore(AktionenStore).add(a);\n                    request.onerror = ev => {\n                        if (request.error.name == \"ConstraintError\") {\n                            console.log(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} bereits gespeichert.`, ev, request.error);\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        } else {\n                            console.error(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} konnte nicht gespeichert werden.`, ev, request.error);\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return db.getAll(NeueBezahlungenStore);\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let sorted = aktionen.map(v => v.laufendeNummer).sort((a, b) => a - b);\n        let i: number;\n        for (i = 0; i < sorted.length - 1; i++) {\n            if (sorted[i] + 1 !== sorted[i + 1]) {\n                break;\n            }\n        }\n        return sorted[i];\n    }\n}","import { expose } from \"comlink\";\nimport { BalanceCalculator } from \"../lib/BalanceCalculator\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { KontokorrentSynchronizer } from \"../lib/KontokorrentSynchronizer\";\n\nconst db = new KontokorrentDatabase();\n\nexport async function calculateBalance(kontokorrentId: string) {\n    return await (new BalanceCalculator(db).calculateBalance(kontokorrentId));\n}\n\nexport async function getLaufendeNummer(kontokorrentId: string) {\n    return await (new KontokorrentSynchronizer(db).getLaufendeNummer(kontokorrentId));\n}\n\nconst exports = {\n    calculateBalance,\n    getLaufendeNummer\n};\nexport type KontokorrentWorkerApi = typeof exports;\nexpose(exports, self);","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module\n\t__webpack_require__(2948);\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + \"23bd790fa21acbb423d0\" + \".bundle.js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + {\"803\":\"31d6cfe0d16ae931b73c\"}[chunkId] + \".css\";\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","__webpack_require__.p = \"/v2/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t948: 1\n};\n\n// importScripts chunk loading\nvar chunkLoadingCallback = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\timportScripts(\"\" + __webpack_require__.u(chunkId));\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkontokorrent\"] = self[\"webpackChunkkontokorrent\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = chunkLoadingCallback;\n\n// no HMR\n\n// no HMR manifest","// run startup\nreturn __webpack_require__.x();\n"],"sourceRoot":""}