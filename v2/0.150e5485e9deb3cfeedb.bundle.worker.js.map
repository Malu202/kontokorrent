{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/comlink/dist/esm/comlink.mjs","webpack:///./node_modules/idb/build/esm/wrap-idb-value.js","webpack:///./node_modules/idb/build/esm/index.js","webpack:///./src/lib/KontokorrentDatabase.ts","webpack:///./src/utils/sortBy.ts","webpack:///./src/utils/groupBy.ts","webpack:///./src/lib/BalanceCalculator.ts","webpack:///./src/lib/filterBezahlungen.ts","webpack:///./src/worker/KontokorrentWorker.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","proxyMarker","createEndpoint","releaseProxy","throwMarker","isObject","val","transferHandlers","Map","canHandle","obj","port1","port2","MessageChannel","expose","port","start","createProxy","ep","path","target","isProxyReleased","proxy","Proxy","_target","prop","throwIfProxyReleased","requestResponseMessage","type","map","toString","then","closeEndPoint","length","fromWireValue","rawValue","transferables","toWireValue","_thisArg","rawArgumentList","last","slice","argumentList","processArguments","serialized","Error","isError","message","stack","assign","self","addEventListener","callback","ev","data","id","returnValue","parent","reduce","apply","transfers","transferCache","set","transfer","undefined","Promise","resolve","catch","wireValue","postMessage","removeEventListener","endpoint","constructor","isMessagePort","close","isReleased","processed","v","arr","Array","concat","WeakMap","handler","serializedValue","serialize","deserialize","msg","fill","Math","floor","random","Number","MAX_SAFE_INTEGER","join","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","receiver","IDBTransaction","objectStoreNames","objectStore","has","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","includes","args","unwrap","this","storeNames","tx","sort","transformCachableValue","done","reject","unlisten","complete","error","DOMException","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","some","IDBRequest","request","promise","success","result","promisifyRequest","newValue","readMethods","writeMethods","cachedMethods","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","returnVal","oldTraps","cb","db","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","openDB","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","withInitialized","collection","getAll","keySelector","k","a","b","toLowerCase","localeCompare","aktionen","tasks","kontokorrentId","add","all","tx2","kk","max","laufendeNummer","appState","kks","getKontokorrents","kontokorrents","existing","filter","e","delete","newIds","ex","find","push","combined","personen","oeffentlicherName","getFromIndex","getAllFromIndex","clear","groupBy","list","forEach","item","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","summe","nenner","andere","bezahlungen","bezahlungenMap","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","values","filterBezahlungen","getAktionen","getKontokorrent","geteilteZahlungen","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","from","keys","gesamtNenner","gesamtSumme","g","erweitern","thisArg","_arguments","P","generator","fulfilled","step","next","rejected","calculateBalance"],"mappings":"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","file":"0.150e5485e9deb3cfeedb.bundle.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/v2/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\r\n * Copyright 2019 Google Inc. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst proxyMarker = Symbol(\"Comlink.proxy\");\r\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\r\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\r\nconst throwMarker = Symbol(\"Comlink.thrown\");\r\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\r\n/**\r\n * Internal transfer handle to handle objects marked to proxy.\r\n */\r\nconst proxyTransferHandler = {\r\n    canHandle: (val) => isObject(val) && val[proxyMarker],\r\n    serialize(obj) {\r\n        const { port1, port2 } = new MessageChannel();\r\n        expose(obj, port1);\r\n        return [port2, [port2]];\r\n    },\r\n    deserialize(port) {\r\n        port.start();\r\n        return wrap(port);\r\n    },\r\n};\r\n/**\r\n * Internal transfer handler to handle thrown exceptions.\r\n */\r\nconst throwTransferHandler = {\r\n    canHandle: (value) => isObject(value) && throwMarker in value,\r\n    serialize({ value }) {\r\n        let serialized;\r\n        if (value instanceof Error) {\r\n            serialized = {\r\n                isError: true,\r\n                value: {\r\n                    message: value.message,\r\n                    name: value.name,\r\n                    stack: value.stack,\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            serialized = { isError: false, value };\r\n        }\r\n        return [serialized, []];\r\n    },\r\n    deserialize(serialized) {\r\n        if (serialized.isError) {\r\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\r\n        }\r\n        throw serialized.value;\r\n    },\r\n};\r\n/**\r\n * Allows customizing the serialization of certain values.\r\n */\r\nconst transferHandlers = new Map([\r\n    [\"proxy\", proxyTransferHandler],\r\n    [\"throw\", throwTransferHandler],\r\n]);\r\nfunction expose(obj, ep = self) {\r\n    ep.addEventListener(\"message\", function callback(ev) {\r\n        if (!ev || !ev.data) {\r\n            return;\r\n        }\r\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\r\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\r\n        let returnValue;\r\n        try {\r\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\r\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\r\n            switch (type) {\r\n                case 0 /* GET */:\r\n                    {\r\n                        returnValue = rawValue;\r\n                    }\r\n                    break;\r\n                case 1 /* SET */:\r\n                    {\r\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\r\n                        returnValue = true;\r\n                    }\r\n                    break;\r\n                case 2 /* APPLY */:\r\n                    {\r\n                        returnValue = rawValue.apply(parent, argumentList);\r\n                    }\r\n                    break;\r\n                case 3 /* CONSTRUCT */:\r\n                    {\r\n                        const value = new rawValue(...argumentList);\r\n                        returnValue = proxy(value);\r\n                    }\r\n                    break;\r\n                case 4 /* ENDPOINT */:\r\n                    {\r\n                        const { port1, port2 } = new MessageChannel();\r\n                        expose(obj, port2);\r\n                        returnValue = transfer(port1, [port1]);\r\n                    }\r\n                    break;\r\n                case 5 /* RELEASE */:\r\n                    {\r\n                        returnValue = undefined;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        catch (value) {\r\n            returnValue = { value, [throwMarker]: 0 };\r\n        }\r\n        Promise.resolve(returnValue)\r\n            .catch((value) => {\r\n            return { value, [throwMarker]: 0 };\r\n        })\r\n            .then((returnValue) => {\r\n            const [wireValue, transferables] = toWireValue(returnValue);\r\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\r\n            if (type === 5 /* RELEASE */) {\r\n                // detach and deactive after sending release response above.\r\n                ep.removeEventListener(\"message\", callback);\r\n                closeEndPoint(ep);\r\n            }\r\n        });\r\n    });\r\n    if (ep.start) {\r\n        ep.start();\r\n    }\r\n}\r\nfunction isMessagePort(endpoint) {\r\n    return endpoint.constructor.name === \"MessagePort\";\r\n}\r\nfunction closeEndPoint(endpoint) {\r\n    if (isMessagePort(endpoint))\r\n        endpoint.close();\r\n}\r\nfunction wrap(ep, target) {\r\n    return createProxy(ep, [], target);\r\n}\r\nfunction throwIfProxyReleased(isReleased) {\r\n    if (isReleased) {\r\n        throw new Error(\"Proxy has been released and is not useable\");\r\n    }\r\n}\r\nfunction createProxy(ep, path = [], target = function () { }) {\r\n    let isProxyReleased = false;\r\n    const proxy = new Proxy(target, {\r\n        get(_target, prop) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            if (prop === releaseProxy) {\r\n                return () => {\r\n                    return requestResponseMessage(ep, {\r\n                        type: 5 /* RELEASE */,\r\n                        path: path.map((p) => p.toString()),\r\n                    }).then(() => {\r\n                        closeEndPoint(ep);\r\n                        isProxyReleased = true;\r\n                    });\r\n                };\r\n            }\r\n            if (prop === \"then\") {\r\n                if (path.length === 0) {\r\n                    return { then: () => proxy };\r\n                }\r\n                const r = requestResponseMessage(ep, {\r\n                    type: 0 /* GET */,\r\n                    path: path.map((p) => p.toString()),\r\n                }).then(fromWireValue);\r\n                return r.then.bind(r);\r\n            }\r\n            return createProxy(ep, [...path, prop]);\r\n        },\r\n        set(_target, prop, rawValue) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\r\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\r\n            const [value, transferables] = toWireValue(rawValue);\r\n            return requestResponseMessage(ep, {\r\n                type: 1 /* SET */,\r\n                path: [...path, prop].map((p) => p.toString()),\r\n                value,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        apply(_target, _thisArg, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const last = path[path.length - 1];\r\n            if (last === createEndpoint) {\r\n                return requestResponseMessage(ep, {\r\n                    type: 4 /* ENDPOINT */,\r\n                }).then(fromWireValue);\r\n            }\r\n            // We just pretend that `bind()` didn’t happen.\r\n            if (last === \"bind\") {\r\n                return createProxy(ep, path.slice(0, -1));\r\n            }\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 2 /* APPLY */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n        construct(_target, rawArgumentList) {\r\n            throwIfProxyReleased(isProxyReleased);\r\n            const [argumentList, transferables] = processArguments(rawArgumentList);\r\n            return requestResponseMessage(ep, {\r\n                type: 3 /* CONSTRUCT */,\r\n                path: path.map((p) => p.toString()),\r\n                argumentList,\r\n            }, transferables).then(fromWireValue);\r\n        },\r\n    });\r\n    return proxy;\r\n}\r\nfunction myFlat(arr) {\r\n    return Array.prototype.concat.apply([], arr);\r\n}\r\nfunction processArguments(argumentList) {\r\n    const processed = argumentList.map(toWireValue);\r\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\r\n}\r\nconst transferCache = new WeakMap();\r\nfunction transfer(obj, transfers) {\r\n    transferCache.set(obj, transfers);\r\n    return obj;\r\n}\r\nfunction proxy(obj) {\r\n    return Object.assign(obj, { [proxyMarker]: true });\r\n}\r\nfunction windowEndpoint(w, context = self, targetOrigin = \"*\") {\r\n    return {\r\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\r\n        addEventListener: context.addEventListener.bind(context),\r\n        removeEventListener: context.removeEventListener.bind(context),\r\n    };\r\n}\r\nfunction toWireValue(value) {\r\n    for (const [name, handler] of transferHandlers) {\r\n        if (handler.canHandle(value)) {\r\n            const [serializedValue, transferables] = handler.serialize(value);\r\n            return [\r\n                {\r\n                    type: 3 /* HANDLER */,\r\n                    name,\r\n                    value: serializedValue,\r\n                },\r\n                transferables,\r\n            ];\r\n        }\r\n    }\r\n    return [\r\n        {\r\n            type: 0 /* RAW */,\r\n            value,\r\n        },\r\n        transferCache.get(value) || [],\r\n    ];\r\n}\r\nfunction fromWireValue(value) {\r\n    switch (value.type) {\r\n        case 3 /* HANDLER */:\r\n            return transferHandlers.get(value.name).deserialize(value.value);\r\n        case 0 /* RAW */:\r\n            return value.value;\r\n    }\r\n}\r\nfunction requestResponseMessage(ep, msg, transfers) {\r\n    return new Promise((resolve) => {\r\n        const id = generateUUID();\r\n        ep.addEventListener(\"message\", function l(ev) {\r\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\r\n                return;\r\n            }\r\n            ep.removeEventListener(\"message\", l);\r\n            resolve(ev.data);\r\n        });\r\n        if (ep.start) {\r\n            ep.start();\r\n        }\r\n        ep.postMessage(Object.assign({ id }, msg), transfers);\r\n    });\r\n}\r\nfunction generateUUID() {\r\n    return new Array(4)\r\n        .fill(0)\r\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\r\n        .join(\"-\");\r\n}\n\nexport { createEndpoint, expose, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst cursorRequestMap = new WeakMap();\nconst transactionDoneMap = new WeakMap();\nconst transactionStoreNamesMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    promise\n        .then((value) => {\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\n        // (see wrapFunction).\n        if (value instanceof IDBCursor) {\n            cursorRequestMap.set(value, request);\n        }\n        // Catching to avoid \"Uncaught Promise exceptions\"\n    })\n        .catch(() => { });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Polyfill for objectStoreNames because of Edge.\n            if (prop === 'objectStoreNames') {\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\n            }\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\n    if (func === IDBDatabase.prototype.transaction &&\n        !('objectStoreNames' in IDBTransaction.prototype)) {\n        return function (storeNames, ...args) {\n            const tx = func.call(unwrap(this), storeNames, ...args);\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\n            return wrap(tx);\n        };\n    }\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(cursorRequestMap.get(this));\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { reverseTransformCache as a, instanceOfAny as i, replaceTraps as r, unwrap as u, wrap as w };\n","import { w as wrap, r as replaceTraps } from './wrap-idb-value.js';\nexport { u as unwrap, w as wrap } from './wrap-idb-value.js';\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\n        });\n    }\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking)\n            db.addEventListener('versionchange', () => blocking());\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked)\n        request.addEventListener('blocked', () => blocked());\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        const returnVal = await target[targetFuncName](...args);\n        if (isWrite)\n            await tx.done;\n        return returnVal;\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nexport { deleteDB, openDB };\n","import { openDB, IDBPDatabase, DBSchema } from \"idb\";\r\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\r\nimport { sortByAlphabetically } from \"../utils/sortBy\";\r\nimport { Aktion } from \"../api/Aktion\";\r\nimport { AktionDbModel } from \"./AktionDbModel\";\r\n\r\n\r\nconst KontokorrentsStore = \"KontokorrentsStore\";\r\nconst AppStateStore = \"AppStateStore\";\r\nconst AktionenStore = \"AktionenStore\";\r\n\r\ninterface AppSettings {\r\n    id: number;\r\n    zuletztGesehenerKontokorrentId: string\r\n}\r\n\r\ninterface KontokorrentDbSchema extends DBSchema {\r\n    KontokorrentsStore: {\r\n        key: string;\r\n        value: KontokorrentDbModel;\r\n        indexes: { \"oeffentlicherName\": string };\r\n    };\r\n    AppStateStore: {\r\n        value: AppSettings;\r\n        key: number;\r\n    };\r\n    AktionenStore: {\r\n        key: [number, string],\r\n        value: AktionDbModel,\r\n        indexes: { \"kontokorrentId\": string };\r\n    };\r\n}\r\n\r\n\r\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null } };\r\nexport class KontokorrentDatabase {\r\n\r\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\r\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 3, {\r\n            upgrade(db, oldVersion: number, newVersion: number) {\r\n                if (oldVersion < 1) {\r\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\r\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\r\n                }\r\n                if (oldVersion < 2) {\r\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\r\n                    store.put(initialSettings());\r\n                }\r\n                if (oldVersion < 3) {\r\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\r\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\r\n                }\r\n            },\r\n        });\r\n        try {\r\n            return await cb(db);\r\n        }\r\n        finally {\r\n            db.close();\r\n        }\r\n    }\r\n\r\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\r\n        return await this.withInitialized(async db => {\r\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\r\n        });\r\n    }\r\n\r\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\r\n        if (!aktionen.length) {\r\n            return;\r\n        }\r\n        return await this.withInitialized(async db => {\r\n            const tx = db.transaction(AktionenStore, \"readwrite\");\r\n            let tasks = aktionen.map(v => {\r\n                let a: AktionDbModel = {\r\n                    ...v,\r\n                    kontokorrentId: id\r\n                };\r\n                return a;\r\n            }).map(a => tx.store.add(a));\r\n            await Promise.all(tasks);\r\n            await tx.done;\r\n            const tx2 = db.transaction(KontokorrentsStore, \"readwrite\");\r\n            let kk = await tx2.store.get(id);\r\n            let max = Math.max(...aktionen.map(v => v.laufendeNummer));\r\n            kk.laufendeNummer = max;\r\n            await tx2.store.put(kk);\r\n            await tx2.done;\r\n        });\r\n    }\r\n\r\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\r\n        return await this.withInitialized(async db => {\r\n            let appState = await db.get(AppStateStore, 0);\r\n            if (appState.zuletztGesehenerKontokorrentId) {\r\n                return appState.zuletztGesehenerKontokorrentId;\r\n            }\r\n            else {\r\n                let kks = await (await this.getKontokorrents());\r\n                if (kks.length) {\r\n                    return kks[0].id;\r\n                }\r\n                return null;\r\n            }\r\n        });\r\n    }\r\n\r\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\r\n        return await this.withInitialized(async db => {\r\n            let appState = await db.get(AppStateStore, 0);\r\n            appState.zuletztGesehenerKontokorrentId = id;\r\n            await db.put(AppStateStore, appState);\r\n        });\r\n    }\r\n\r\n    async setKontokorrents(kontokorrents: {\r\n        name: string, id: string, personen: { name: string, id: string }[],\r\n        oeffentlicherName: string\r\n    }[]): Promise<string[]> {\r\n        return await this.withInitialized(async db => {\r\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\r\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\r\n                await db.delete(KontokorrentsStore, v.id);\r\n            }\r\n            let newIds: string[] = [];\r\n            for (let v of kontokorrents) {\r\n                let ex = existing.find(d => d.id == v.id);\r\n                if (!ex) {\r\n                    newIds.push(v.id);\r\n                }\r\n                let combined = {\r\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\r\n                    oeffentlicherName: v.oeffentlicherName\r\n                };\r\n                await db.put(KontokorrentsStore, combined);\r\n            }\r\n            return newIds;\r\n        });\r\n    }\r\n\r\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\r\n        return await this.withInitialized(async db => {\r\n            if (!await db.get(KontokorrentsStore, kk.id)) {\r\n                await db.add(KontokorrentsStore, kk);\r\n            }\r\n        });\r\n    }\r\n\r\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\r\n        return await this.withInitialized(async db => {\r\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\r\n        });\r\n    }\r\n\r\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\r\n        return await this.withInitialized(async db => {\r\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\r\n        });\r\n    }\r\n\r\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\r\n        return await this.withInitialized(async db => {\r\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\r\n        });\r\n    }\r\n\r\n    async clear() {\r\n        return await this.withInitialized(async db => {\r\n            await db.clear(AktionenStore);\r\n            await db.clear(KontokorrentsStore);\r\n            await db.put(AppStateStore, initialSettings());\r\n        });\r\n    }\r\n}\r\n\r\n","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\r\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\r\n}","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\r\n    const map = new Map<T[K], T[]>();\r\n    list.forEach((item) => {\r\n        const k = item[key];\r\n        const collection = map.get(k);\r\n        if (!collection) {\r\n            map.set(k, [item]);\r\n        } else {\r\n            collection.push(item);\r\n        }\r\n    });\r\n    return map;\r\n}\r\n","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\r\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\r\nimport { filterBezahlungen } from \"./filterBezahlungen\";\r\nimport { groupBy } from \"../utils/groupBy\";\r\n\r\nclass GeteilteZahlung {\r\n    constructor(public wert: number,\r\n        public empfaengerAnzahl: number,\r\n        public isEmpfaenger: boolean) {\r\n\r\n    }\r\n}\r\n\r\nexport class BalanceCalculator {\r\n    private db: KontokorrentDatabase;\r\n\r\n    constructor() {\r\n        this.db = new KontokorrentDatabase();\r\n    }\r\n\r\n    erweitern(summe: number, nenner: number, andere: number[]) {\r\n        let c = 1;\r\n        for (let n of andere) {\r\n            if (n != nenner) {\r\n                c *= n;\r\n            }\r\n        }\r\n        return summe * c;\r\n    }\r\n\r\n    async calculateBalance(kontokorrentId: string) {\r\n        let aktionen = await this.db.getAktionen(kontokorrentId);\r\n        let bezahlungen = filterBezahlungen(aktionen);\r\n        let kk = await this.db.getKontokorrent(kontokorrentId);\r\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\r\n        for (let p of kk.personen) {\r\n            geteilteZahlungen[p.id] = [];\r\n        }\r\n        for (let b of bezahlungen) {\r\n            for (let e of b.empfaengerIds) {\r\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\r\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\r\n            }\r\n        }\r\n        let balance: KontokorrentBalance = {};\r\n        for (let p of kk.personen) {\r\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\r\n            let alleNenner = Array.from(gruppen.keys());\r\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\r\n            if (gesamtNenner < 362880) {\r\n                let gesamtSumme = 0;\r\n                for (let g of gruppen.keys()) {\r\n                    let zahlungen = gruppen.get(g);\r\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\r\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\r\n                }\r\n                balance[p.id] = gesamtSumme / gesamtNenner;\r\n            }\r\n            else {\r\n                let gesamtSumme = 0;\r\n                for (let g of gruppen.keys()) {\r\n                    let zahlungen = gruppen.get(g);\r\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\r\n                    gesamtSumme += summe / g;\r\n                }\r\n                balance[p.id] = gesamtSumme;\r\n            }\r\n        }\r\n        return balance;\r\n    }\r\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\r\nimport { AktionDbModel } from \"./AktionDbModel\";\r\n\r\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\r\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\r\n    for (let b of aktionen) {\r\n        if (b.bearbeiteteBezahlungId) {\r\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\r\n        }\r\n        if (b.geloeschteBezahlungId) {\r\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\r\n        }\r\n        else {\r\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\r\n        }\r\n    }\r\n    let bezahlungen = Object.values(bezahlungenMap);\r\n    return bezahlungen;\r\n}","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nimport { expose } from \"comlink\";\r\nimport { BalanceCalculator } from \"../lib/BalanceCalculator\";\r\nexport function calculateBalance(kontokorrentId) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        return yield (new BalanceCalculator().calculateBalance(kontokorrentId));\r\n    });\r\n}\r\nconst exports = {\r\n    calculateBalance\r\n};\r\nexpose(exports, self);\r\n"],"sourceRoot":""}