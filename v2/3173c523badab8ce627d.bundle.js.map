{"version":3,"file":"3173c523badab8ce627d.bundle.js","mappings":"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","sources":["webpack://kontokorrent/webpack/runtime/chunk loaded","webpack://kontokorrent/webpack/runtime/startup chunk dependencies","webpack://kontokorrent/./src/lib/AccountType.ts","webpack://kontokorrent/./src/api/postJson.ts","webpack://kontokorrent/./src/api/TokenRenewFailedException.ts","webpack://kontokorrent/./src/api/InteractionRequiredException.ts","webpack://kontokorrent/./src/api/ApiException.ts","webpack://kontokorrent/./src/environment.ts","webpack://kontokorrent/./src/api/NeueBezahlungFailedException.ts","webpack://kontokorrent/./src/api/BezahlungBearbeitenFailedException.ts","webpack://kontokorrent/./src/api/BezahlungLoeschenFailedException.ts","webpack://kontokorrent/./src/api/ApiClient.ts","webpack://kontokorrent/./src/lib/KontokorrentDatabase.ts","webpack://kontokorrent/./src/state/State.ts","webpack://kontokorrent/./src/utils/groupBy.ts","webpack://kontokorrent/./src/state/actions/BeschreibungVorschlagActionCreator.ts","webpack://kontokorrent/./src/lib/filterBezahlungen.ts","webpack://kontokorrent/./src/lib/KontokorrentSynchronizer.ts","webpack://kontokorrent/./src/lib/BalanceCalculator.ts","webpack://kontokorrent/./src/state/actions/KontokorrentSyncActionCreator.ts","webpack://kontokorrent/./src/worker/KontokorrentWorker.ts","webpack://kontokorrent/./src/utils/sortBy.ts","webpack://kontokorrent/./src/lib/AccountInfoStore.ts","webpack://kontokorrent/./node_modules/core-js/internals/object-get-own-property-names.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim-forced.js","webpack://kontokorrent/./node_modules/core-js/internals/string-trim.js","webpack://kontokorrent/./node_modules/core-js/internals/whitespaces.js","webpack://kontokorrent/./node_modules/core-js/modules/es.string.trim.js","webpack://kontokorrent/webpack/bootstrap","webpack://kontokorrent/webpack/runtime/define property getters","webpack://kontokorrent/webpack/runtime/ensure chunk","webpack://kontokorrent/webpack/runtime/get javascript chunk filename","webpack://kontokorrent/webpack/runtime/get mini-css chunk filename","webpack://kontokorrent/webpack/runtime/global","webpack://kontokorrent/webpack/runtime/hasOwnProperty shorthand","webpack://kontokorrent/webpack/runtime/publicPath","webpack://kontokorrent/webpack/runtime/importScripts chunk loading","webpack://kontokorrent/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(820).then(next);\n};","export enum AccountType {\n    google = \"google\",\n    anonym = \"anonym\"\n};\n","export async function postJson(url: string, body: any, token?: string) {\n    let init: RequestInit = {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(body)\n    };\n    if (token) {\n        init.headers = { ...init.headers, \"Authorization\": `Bearer ${token}` };\n    }\n    return await fetch(url, init);\n}","export class TokenRenewFailedException {\n    constructor(public readonly networkError: boolean) {\n\n    }\n}","export class InteractionRequiredException {\n\n}\n\n","\nexport class ApiException {\n}\n","let API_URL;\nif (__ENVIRONMENT == \"local\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pages\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse if (__ENVIRONMENT == \"gh-pagesv2\") {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\nelse {\n    API_URL = \"https://kontokorrent.azurewebsites.net\";\n}\n\nexport const environment = {\n    API_URL: API_URL\n};\n","\nexport class NeueBezahlungFailedException {\n}\n\n\n","\nexport class BezahlungBearbeitenFailedException {\n}\n","\nexport class BezahlungLoeschenFailedException {\n}\n","import { postJson } from \"./postJson\";\nimport { AccountType } from \"../lib/AccountType\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentInfo } from \"./KontokorrentInfo\";\nimport { NeuerKontokorrentRequest } from \"./NeuerKontokorrentRequest\";\nimport { TokenRenewFailedException } from \"./TokenRenewFailedException\";\nimport { InteractionRequiredException } from \"./InteractionRequiredException\";\nimport { ApiException } from \"./ApiException\";\nimport { Aktion } from \"./Aktion\";\nimport { environment } from \"../environment\";\nimport { NeueBezahlungRequest } from \"./NeueBezahlungRequest\";\nimport { NeueBezahlungFailedException } from \"./NeueBezahlungFailedException\";\nimport { BezahlungBearbeitenRequest } from \"./BezahlungBearbeitenRequest\";\nimport { BezahlungBearbeitenFailedException } from \"./BezahlungBearbeitenFailedException\";\nimport { BezahlungLoeschenFailedException } from \"./BezahlungLoeschenFailedException\";\n\nconst baseUrl = environment.API_URL;\n\nexport class ApiClient {\n\n    constructor(private accountInfoStore: AccountInfoStore) {\n\n    }\n\n    async neuerBenutzer(id: string, secret: string) {\n        try {\n            let res = await postJson(`${baseUrl}/api/v2/accounts`, { id, secret });\n            if (!res.ok) {\n                return { success: false };\n            }\n            return { success: true };\n        }\n        catch(err) {\n            return { success: false };\n        }\n    }\n\n    async getUserInfo() {\n        let res = await fetch(`${baseUrl}/api/v2/userinfo`, { headers: await this.getAuthHeader() });\n        return await res.json();\n    }\n\n    private async getAuthHeader() {\n        return { \"Authorization\": `Bearer ${await this.getAccessToken()}` };\n    }\n\n    async kontokorrentHinzufuegen(oeffentlicherName: string, einladungsCode: string) {\n        let params = \"\";\n        if (oeffentlicherName) {\n            params = `oeffentlicherName=${encodeURIComponent(oeffentlicherName)}`;\n        }\n        else {\n            params = `einladungsCode=${encodeURIComponent(einladungsCode)}`;\n        }\n        let headers = await this.getAuthHeader();\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents?${params}`, { method: \"PUT\", headers: headers });\n        if (res.status == 404) {\n            return null;\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n    async kontokorrentsAuflisten() {\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents`, { headers: await this.getAuthHeader() });\n        if (!res.ok) {\n            throw new ApiException();\n        }\n        return <KontokorrentInfo[]>await res.json();\n    }\n\n\n    async neuerKontokorrent(request: NeuerKontokorrentRequest) {\n        let res = await postJson(`${baseUrl}/api/v2/kontokorrents`, request, await this.getAccessToken());\n        if (res.status == 422) {\n            return { success: false, exists: true };\n        }\n        else if (res.ok) {\n            return { success: true };\n        }\n        return { success: false };\n    }\n\n    async getAktionen(kontokorrentId: string, ab?: number) {\n        let query = ab ? `?ab=${ab}` : \"\";\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen${query}`, { headers: await this.getAuthHeader() });\n        if (res.status == 404) {\n            return {\n                success: false,\n                notfound: true\n            };\n        }\n        else if (res.ok) {\n            let aktionen: Aktion[] = await res.json();\n            return {\n                success: true,\n                aktionen: this.mapAktionen(aktionen)\n            }\n        }\n    }\n\n    private mapAktionen(aktionen : Aktion[]) : Aktion[] {\n        for (let a of aktionen) {\n            if (a.bezahlung) {\n                a.bezahlung.zeitpunkt = new Date(a.bezahlung.zeitpunkt);\n            }\n        }\n        return aktionen;\n    }\n\n    async neueBezahlung(kontokorrentId: string, request: NeueBezahlungRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.hinzufuegenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new NeueBezahlungFailedException();\n    }\n\n    async bezahlungLoeschen(kontokorrentId: string, bezahlungId:string) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.loeschenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify({id:bezahlungId})\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungLoeschenFailedException();\n    }\n\n    async bezahlungBearbeiten(kontokorrentId: string, request: BezahlungBearbeitenRequest) {\n        let init: RequestInit = {\n            method: \"POST\",\n            headers: {\n                \"Accept\": \"application/json\",\n                \"Content-Type\": \"application/vnd+kontokorrent.bearbeitenaktion+json\",\n                \"Authorization\": `Bearer ${await this.getAccessToken()}`\n            },\n            body: JSON.stringify(request)\n        };\n        let res = await fetch(`${baseUrl}/api/v2/kontokorrents/${kontokorrentId}/aktionen`, init);\n        if (res.ok) {\n            let aktion = <Aktion>(await res.json());\n            return this.mapAktionen([aktion])[0];\n        }\n        throw new BezahlungBearbeitenFailedException();\n    }\n\n\n    private async getAccessToken() {\n        let info = await this.accountInfoStore.get();\n        if (null == info) {\n            throw new Error(\"Keine Account Information gespeichert.\");\n        }\n        if (info.type == AccountType.anonym) {\n            let tokenInfo = await this.accountInfoStore.getAccessToken(\"anonymous\");\n            if (null != tokenInfo) {\n                let { token, expires } = JSON.parse(tokenInfo.value);\n                if (token && expires && expires >= +new Date()) {\n                    return token;\n                }\n            }\n            let tokenResponse;\n            try {\n                let res = await postJson(`${baseUrl}/api/v2/token`, { id: info.id, secret: info.secret });\n                if (!res.ok) {\n                    throw new TokenRenewFailedException(false);\n                }\n                tokenResponse = await res.json();\n            }\n            catch(err) {\n                throw new TokenRenewFailedException(true);\n            }\n            await this.accountInfoStore.updateAccessTokenIfNewer(\"anonymous\", JSON.stringify(tokenResponse), tokenInfo?.timestamp);\n            return tokenResponse.token;\n        }\n        else if (info.type == AccountType.google) {\n            throw new InteractionRequiredException();\n            // let flow = new OAuth2PopupFlow({\n            //     authorizationUri: \"https://accounts.google.com/o/oauth2/v2/auth/.well-known/openid-configuration\",\n            //     clientId: \"82890837151-n0e81vsn3ns2qn1ksh7bdohmnlau468k.apps.googleusercontent.com\",\n            //     redirectUri: \"http://localhost:4200\",\n            //     scope: \"openid\",\n            //     responseType: \"id_token\",\n            //     additionalAuthorizationParameters: { \"login_hint\": info.id },\n            //     accessTokenStorageKey: \"access_token_google\"\n            // });\n            // return await flow.token();\n        }\n        else {\n            throw new Error(`Account Typ ${info.type} unbekannt`);\n        }\n    }\n}","import { openDB, IDBPDatabase, DBSchema, unwrap } from \"idb\";\nimport { KontokorrentDbModel } from \"./KontokorrentDbModel\";\nimport { sortByAlphabetically } from \"../utils/sortBy\";\nimport { Aktion } from \"../api/Aktion\";\nimport { AktionDbModel } from \"./AktionDbModel\";\nimport { AccountInfo } from \"./AccountInfo\";\nimport { NeueBezahlungDbModel } from \"./NeueBezahlungDbModel\";\nimport { BearbeitungsStatus } from \"./BearbeitungsStatus\";\n\n\nconst KontokorrentsStore = \"KontokorrentsStore\";\nconst AppStateStore = \"AppStateStore\";\nconst AktionenStore = \"AktionenStore\";\nconst NeueBezahlungenStore = \"NeueBezahlungenStore\";\n\ninterface AccessTokenInfo {\n    timestamp: number;\n    value: string;\n    type: \"google\" | \"anonymous\";\n}\n\ninterface AppSettings {\n    id: number;\n    zuletztGesehenerKontokorrentId: string\n    accesstokens: AccessTokenInfo[];\n    accountinfo: AccountInfo;\n}\n\ninterface KontokorrentDbSchema extends DBSchema {\n    KontokorrentsStore: {\n        key: string;\n        value: KontokorrentDbModel;\n        indexes: { \"oeffentlicherName\": string };\n    };\n    AppStateStore: {\n        value: AppSettings;\n        key: number;\n    };\n    AktionenStore: {\n        key: [number, string],\n        value: AktionDbModel,\n        indexes: { \"kontokorrentId\": string };\n    };\n    NeueBezahlungenStore: {\n        key: string,\n        value: NeueBezahlungDbModel,\n        indexes: { \"kontokorrentId\": string };\n    }\n}\n\n\nconst initialSettings: (() => AppSettings) = () => { return { id: 0, zuletztGesehenerKontokorrentId: null, accesstokens: [], accountinfo: null } };\nexport class KontokorrentDatabase {\n\n    private async withInitialized<T>(cb: (db: IDBPDatabase<KontokorrentDbSchema>) => Promise<T>) {\n        let db = await openDB<KontokorrentDbSchema>(\"kontokorrent-db\", 5, {\n            upgrade(db, oldVersion: number, newVersion: number) {\n                if (oldVersion < 1) {\n                    let store = db.createObjectStore(KontokorrentsStore, { keyPath: \"id\" });\n                    store.createIndex(\"oeffentlicherName\", \"oeffentlicherName\");\n                }\n                if (oldVersion < 2) {\n                    let store = db.createObjectStore(AppStateStore, { keyPath: \"id\" });\n                    store.put(initialSettings());\n                }\n                if (oldVersion < 3) {\n                    let store = db.createObjectStore(AktionenStore, { keyPath: [\"laufendeNummer\", \"kontokorrentId\"] });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n                if (oldVersion < 5) {\n                    if (db.objectStoreNames.contains(NeueBezahlungenStore)) {\n                        db.deleteObjectStore(NeueBezahlungenStore)\n                    }\n                    let store = db.createObjectStore(NeueBezahlungenStore, { keyPath: \"id\" });\n                    store.createIndex(\"kontokorrentId\", \"kontokorrentId\");\n                }\n            },\n        });\n        try {\n            return await cb(db);\n        }\n        finally {\n            db.close();\n        }\n    }\n\n    async getKontokorrents(): Promise<KontokorrentDbModel[]> {\n        return await this.withInitialized(async db => {\n            return sortByAlphabetically((await db.getAll(KontokorrentsStore)), k => k.name);\n        });\n    }\n\n    async addAktionen(id: string, aktionen: Aktion[]): Promise<void> {\n        if (!aktionen.length) {\n            return;\n        }\n        let mapped = aktionen\n            .map(v => {\n                let a: AktionDbModel = {\n                    ...v,\n                    kontokorrentId: id\n                };\n                return a;\n            });\n        return await this.withInitialized(db => {\n            const unwrapped = unwrap(<IDBPDatabase>db);\n            return new Promise((resolve, reject) => {\n                const tx = unwrapped.transaction(AktionenStore, \"readwrite\");\n                tx.onerror = err => {\n                    console.error(\"addAktionen failed\", err, tx.error);\n                    reject(tx.error);\n                };\n                tx.oncomplete = () => {\n                    resolve();\n                }\n                for (let a of mapped) {\n                    let request = tx.objectStore(AktionenStore).add(a);\n                    request.onerror = ev => {\n                        if (request.error.name == \"ConstraintError\") {\n                            console.log(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} bereits gespeichert.`, ev, request.error);\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                        } else {\n                            console.error(`Aktion ${a.laufendeNummer} für Kontokorrent ${id} konnte nicht gespeichert werden.`, ev, request.error);\n                        }\n                    }\n                }\n            });\n        });\n    }\n\n    async getZuletztGesehenerKontokorrentId(): Promise<string> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            if (appState.zuletztGesehenerKontokorrentId) {\n                return appState.zuletztGesehenerKontokorrentId;\n            }\n            else {\n                let kks = await (await this.getKontokorrents());\n                if (kks.length) {\n                    return kks[0].id;\n                }\n                return null;\n            }\n        });\n    }\n\n    async setZuletztGesehenerKontokorrentId(id: string): Promise<void> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            appState.zuletztGesehenerKontokorrentId = id;\n            await db.put(AppStateStore, appState);\n        });\n    }\n\n    async setKontokorrents(kontokorrents: {\n        name: string, id: string, personen: { name: string, id: string }[],\n        oeffentlicherName: string\n    }[]): Promise<string[]> {\n        return await this.withInitialized(async db => {\n            let existing: KontokorrentDbModel[] = (await db.getAll(KontokorrentsStore));\n            for (let v of existing.filter(e => !kontokorrents.some(d => e.id === d.id))) {\n                await db.delete(KontokorrentsStore, v.id);\n            }\n            let newIds: string[] = [];\n            for (let v of kontokorrents) {\n                let ex = existing.find(d => d.id == v.id);\n                if (!ex) {\n                    newIds.push(v.id);\n                }\n                let combined = {\n                    ...ex, name: v.name, personen: v.personen, id: v.id,\n                    oeffentlicherName: v.oeffentlicherName\n                };\n                await db.put(KontokorrentsStore, combined);\n            }\n            return newIds;\n        });\n    }\n\n    async addKontokorrent(kk: KontokorrentDbModel): Promise<void> {\n        return await this.withInitialized(async db => {\n            if (!await db.get(KontokorrentsStore, kk.id)) {\n                await db.add(KontokorrentsStore, kk);\n            }\n        });\n    }\n\n    async getKontokorrent(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.get(KontokorrentsStore, id);\n        });\n    }\n\n    async getPerOeffentlichName(id: string): Promise<KontokorrentDbModel> {\n        return await this.withInitialized(async db => {\n            return <KontokorrentDbModel>await db.getFromIndex(KontokorrentsStore, \"oeffentlicherName\", id);\n        });\n    }\n\n    async getAktionen(id: string): Promise<AktionDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", id);\n        });\n    }\n\n    async clear() {\n        return await this.withInitialized(async db => {\n            await db.clear(AktionenStore);\n            await db.clear(KontokorrentsStore);\n            await db.put(AppStateStore, initialSettings());\n        });\n    }\n\n    async getAccessToken(tokenType: \"anonymous\" | \"google\"): Promise<AccessTokenInfo> {\n        return await this.withInitialized(async db => {\n            let appState = await db.get(AppStateStore, 0);\n            return (appState.accesstokens || []).find(t => t.type === tokenType);\n        });\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number): Promise<boolean> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\", { durability: \"strict\" });\n            let appState = await tx.store.get(0);\n            if (!appState.accesstokens) {\n                appState.accesstokens = [];\n            }\n            let existing = appState.accesstokens.find(t => t.type === tokenType);\n            if (!existing) {\n                appState.accesstokens.push({\n                    timestamp: 1,\n                    type: tokenType,\n                    value: value\n                });\n            } else if (existing.timestamp == lastTimeStamp) {\n                existing.value = value;\n                existing.timestamp++;\n            }\n            else {\n                console.error(`The accesstoken of type ${tokenType} was already updated since reading.`);\n                await tx.done;\n                return false;\n            }\n            await tx.store.put(appState);\n            await tx.done;\n            return true;\n        });\n    }\n\n    async setAccountInfo(accountInfo: AccountInfo): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = accountInfo;\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getAccountInfo(): Promise<AccountInfo> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readonly\");\n            let appState = await tx.store.get(0);\n            return appState?.accountinfo;\n        });\n    }\n\n    async clearAccountInfo(): Promise<void> {\n        return await this.withInitialized(async db => {\n            const tx = db.transaction(AppStateStore, \"readwrite\");\n            let appState = await tx.store.get(0);\n            appState.accountinfo = null;\n            appState.accesstokens = [];\n            await tx.store.put(appState);\n            await tx.done;\n        });\n    }\n\n    async getZwischengespeicherteBezahlungen(): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return (await db.getAll(NeueBezahlungenStore));\n        });\n    }\n\n    async getBezahlungAktion(kontokorrentId: string, bezahlungId: string): Promise<AktionDbModel> {\n        return await this.withInitialized(async db => {\n            var aktionen = db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            return (await aktionen).find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n        });\n    }\n\n    async getBearbeitungsStatus(kontokorrentId: string, bezahlungId: string): Promise<{ aktion: AktionDbModel, status: BearbeitungsStatus }> {\n        return await this.withInitialized(async db => {\n            let aktionen: AktionDbModel[] = await db.getAllFromIndex(AktionenStore, \"kontokorrentId\", kontokorrentId);\n            let aktion = aktionen.find(a => a.bezahlung && a.bezahlung.id == bezahlungId);\n            if (!aktion) {\n                let neueBezahlungen: NeueBezahlungDbModel[] = await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n                let neueBezahlung = neueBezahlungen.find(a => a.id == bezahlungId);\n                if (neueBezahlung) {\n                    return { aktion: null, status: BearbeitungsStatus.Zwischengespeichert };\n                }\n                return { aktion: null, status: BearbeitungsStatus.NichtGefunden };\n            }\n            let bearbeitendeAktion = aktionen.find(a => a.bearbeiteteBezahlungId == bezahlungId);\n            if (null != bearbeitendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Bearbeitet };\n            }\n            let loeschendeAktion = aktionen.find(a => a.geloeschteBezahlungId == bezahlungId);\n            if (null != loeschendeAktion) {\n                return { aktion: aktion, status: BearbeitungsStatus.Geloescht };\n            }\n            return { aktion: aktion, status: BearbeitungsStatus.Bearbeitbar };\n        });\n    }\n\n    async getZwischengespeicherteBezahlungenForKontokorrent(kontokorrentId: string): Promise<NeueBezahlungDbModel[]> {\n        return await this.withInitialized(async db => {\n            return await db.getAllFromIndex(NeueBezahlungenStore, \"kontokorrentId\", kontokorrentId);\n        });\n    }\n\n    async bezahlungZwischenspeichern(m: NeueBezahlungDbModel) {\n        return await this.withInitialized(async db => {\n            db.add(NeueBezahlungenStore, m);\n        });\n    }\n\n    async zwischengespeicherteBezahlungErledigt(id: string) {\n        await this.withInitialized(async db => {\n            db.delete(NeueBezahlungenStore, id);\n        });\n    }\n}\n","import { AccountInfo } from \"../lib/AccountInfo\";\nimport { BearbeitungsStatus } from \"../lib/BearbeitungsStatus\";\n\nexport interface AccountState {\n    accountCreated: boolean,\n    accountCreating: boolean,\n    accountCreationFailed: boolean\n    loginExpired: boolean;\n    accountInfo: AccountInfo\n}\n\nexport interface KontokorrentsState {\n    kontokorrents: { [id: string]: KontokorrentState };\n    hinzufuegen: boolean;\n    listeLaden: boolean;\n    hinzufuegenFailed: {\n        kontokorrentNotFound: boolean\n    }\n    creating: boolean;\n    creationFailed: { exists: boolean };\n    activeKontokorrentId: string;\n}\n\nexport interface Person {\n    name: string;\n    id: string;\n    balance: number;\n}\n\nexport enum BezahlungStatus {\n    Zwischengespeichert = \"zwischengespeichert\",\n    Speichern = \"speichern\",\n    Gespeichert = \"gespeichert\"\n}\n\nexport interface Bezahlung {\n    id: string;\n    zeitpunkt: Date;\n    bezahlendePersonId: string;\n    empfaengerIds: string[];\n    wert: number;\n    beschreibung: string;\n    status: BezahlungStatus\n}\n\nexport const enum RequestStatus {\n    InProgress,\n    Success,\n    Failed\n}\n\nexport interface AngezeigteBezahlungState {\n    bearbeitungsStatus: BearbeitungsStatus;\n    updateStatus?: RequestStatus;\n    deleteStatus?: RequestStatus;\n}\n\nexport interface KontokorrentState {\n    id: string;\n    name: string;\n    oeffentlicherName:string;\n    personen: Person[];\n    bezahlungen: Bezahlung[];\n    synchronisieren: boolean;\n    bezahlungAnlegen: RequestStatus;\n    angezeigteBezahlung: { [id: string]: AngezeigteBezahlungState }\n}\n\nexport interface BeschreibungVorschlagState {\n    kontokorrentId: string;\n    vorschlaege: string[];\n}\n\nexport interface State {\n    account: AccountState\n    kontokorrents: KontokorrentsState;\n    beschreibungVorschlaege: BeschreibungVorschlagState;\n}\n","export function groupBy<T, K extends keyof T>(list: T[], key: K) {\n    const map = new Map<T[K], T[]>();\n    list.forEach((item) => {\n        const k = item[key];\n        const collection = map.get(k);\n        if (!collection) {\n            map.set(k, [item]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n}\n","import { Store } from \"../lib/Store\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { ActionNames } from \"./ActionNames\";\nimport { Action } from \"../lib/Action\";\nimport { groupBy } from \"../../utils/groupBy\";\n\nexport class BeschreibungsVorschlaege implements Action {\n    readonly type = ActionNames.BeschreibungsVorschlaege;\n    constructor(public kontokorrentId: string, public vorschlaege: string[]) {\n\n    }\n}\n\nexport type BeschreibungVorschlagActions =\n    | BeschreibungsVorschlaege;\n\nexport class BeschreibungVorschlagActionCreator {\n    private beschreibungenCache: { kontokorrentId: string, beschreibungen: { search: string, result: string, occurence: number }[] };\n    constructor(private db: KontokorrentDatabase, private store: Store) {\n        this.resetCache();\n    }\n\n\n    private formatSearchString(s: string) {\n        return s.toLowerCase().replace(/\\s|-/g, \"\");\n    }\n\n    private sameChars(s: string, d: string) {\n        let i;\n        for (i = 0; i < Math.min(s.length, d.length); i++) {\n            if (s[i] != d[i]) {\n                break;\n            }\n        }\n        return i;\n    }\n\n    resetCache() {\n        this.beschreibungenCache = { kontokorrentId: null, beschreibungen: [] };\n    }\n\n    async getVorschlaege(kontokorrentId: string, eingabe: string) {\n        if (this.beschreibungenCache.kontokorrentId != kontokorrentId) {\n            let aktionen = await this.db.getAktionen(kontokorrentId);\n            let beschreibungen = aktionen.filter(a => null != a.bezahlung?.beschreibung).map(a => {\n                return { search: this.formatSearchString(a.bezahlung.beschreibung), result: a.bezahlung.beschreibung.trim() }\n            });\n            this.beschreibungenCache.kontokorrentId = kontokorrentId;\n            let map = groupBy(beschreibungen, \"search\");\n            this.beschreibungenCache.beschreibungen = Array.from(map.entries()).map(([search, r]) => {\n\n                return {\n                    search,\n                    result: r[0].result,\n                    occurence: r.length\n                };\n            }).sort((a, b) => b.occurence - a.occurence);\n        }\n        if (eingabe) {\n            let formatted = this.formatSearchString(eingabe);\n            let vorschlaege = this.beschreibungenCache.beschreibungen\n                .filter(({ search }) => search.indexOf(formatted) > -1)\n                .map(({ search, result }) => {\n                    return { result, score: this.sameChars(formatted, search) }\n                }).sort((a, b) => b.score - a.score);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege.map(b => b.result)));\n        }\n        else {\n            let vorschlaege = this.beschreibungenCache.beschreibungen.slice(0, 10).map(b => b.result);\n            this.store.dispatch(new BeschreibungsVorschlaege(kontokorrentId, vorschlaege));\n        }\n    }\n}","import { BezahlungDbModel } from \"./BezahlungDbModel\";\nimport { AktionDbModel } from \"./AktionDbModel\";\n\nexport function filterBezahlungen(aktionen: AktionDbModel[]) {\n    let bezahlungenMap: { [id: string]: BezahlungDbModel } = {};\n    let ordered = aktionen.sort((a,b)=> a.laufendeNummer - b.laufendeNummer);\n    for (let b of ordered) {\n        if (b.bearbeiteteBezahlungId) {\n            delete bezahlungenMap[b.bearbeiteteBezahlungId];\n        }\n        if (b.geloeschteBezahlungId) {\n            delete bezahlungenMap[b.geloeschteBezahlungId];\n        }\n        else {\n            bezahlungenMap[b.bezahlung.id] = b.bezahlung;\n        }\n    }\n    let bezahlungen = Object.values(bezahlungenMap);\n    return bezahlungen;\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class KontokorrentSynchronizer {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    async getLaufendeNummer(kontokorrentId: string) {\n        let aktionen = await this.db.getAktionen(kontokorrentId);\n        let sorted = aktionen.map(v => v.laufendeNummer).sort((a, b) => a - b);\n        let i: number;\n        for (i = 0; i < sorted.length - 1; i++) {\n            if (sorted[i] + 1 !== sorted[i + 1]) {\n                break;\n            }\n        }\n        return sorted[i];\n    }\n}","import { KontokorrentDatabase } from \"./KontokorrentDatabase\";\nimport { KontokorrentBalance } from \"./KontokorrentBalance\";\nimport { filterBezahlungen } from \"./filterBezahlungen\";\nimport { groupBy } from \"../utils/groupBy\";\n\nclass GeteilteZahlung {\n    constructor(public wert: number,\n        public empfaengerAnzahl: number,\n        public isEmpfaenger: boolean) {\n\n    }\n}\n\ntype Bezahlung = { empfaengerIds: string[], bezahlendePersonId: string, wert: number };\n\ninterface KontokorrentBalanceRequest {\n    kontokorrentId: string;\n    zwischengespeicherte: boolean;\n    bisLaufendeNummer: null | number;\n}\n\ninterface KontokorrentBalanceResult {\n    bezahlungen: Bezahlung[];\n    balance: KontokorrentBalance;\n}\n\nexport class BalanceCalculator {\n    constructor(private db: KontokorrentDatabase) {\n    }\n\n    private erweitern(summe: number, nenner: number, andere: number[]) {\n        let c = 1;\n        for (let n of andere) {\n            if (n != nenner) {\n                c *= n;\n            }\n        }\n        return summe * c;\n    }\n\n    async getBalance(request: KontokorrentBalanceRequest): Promise<KontokorrentBalanceResult> {\n        let aktionen = await this.db.getAktionen(request.kontokorrentId);\n        if (request.bisLaufendeNummer) {\n            aktionen = aktionen.filter(a => a.laufendeNummer <= request.bisLaufendeNummer);\n        }\n        let gespeicherte: Bezahlung[] = filterBezahlungen(aktionen);\n        let bezahlungen: Bezahlung[];\n        let zwischengespeicherte: Bezahlung[] = await this.db.getZwischengespeicherteBezahlungenForKontokorrent(request.kontokorrentId);\n        if (request.zwischengespeicherte) {\n            bezahlungen = [...zwischengespeicherte, ...gespeicherte];\n        } else {\n            bezahlungen = gespeicherte;\n        }\n        let kk = await this.db.getKontokorrent(request.kontokorrentId);\n        let geteilteZahlungen: { [id: string]: GeteilteZahlung[] } = {};\n        for (let p of kk.personen) {\n            geteilteZahlungen[p.id] = [];\n        }\n        for (let b of bezahlungen) {\n            for (let e of b.empfaengerIds) {\n                geteilteZahlungen[e].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, true));\n                geteilteZahlungen[b.bezahlendePersonId].push(new GeteilteZahlung(b.wert, b.empfaengerIds.length, false));\n            }\n        }\n        let balance: KontokorrentBalance = {};\n        for (let p of kk.personen) {\n            let gruppen = groupBy(geteilteZahlungen[p.id], \"empfaengerAnzahl\");\n            let alleNenner = Array.from(gruppen.keys());\n            let gesamtNenner = Array.from(gruppen.keys()).reduce((p, c) => p * c, 1);\n            if (gesamtNenner < 362880) {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += this.erweitern(summe, g, alleNenner);\n                }\n                balance[p.id] = gesamtSumme / gesamtNenner;\n            }\n            else {\n                let gesamtSumme = 0;\n                for (let g of gruppen.keys()) {\n                    let zahlungen = gruppen.get(g);\n                    let summe = zahlungen.reduce((p, c) => p + (c.isEmpfaenger ? c.wert : -c.wert), 0);\n                    gesamtSumme += summe / g;\n                }\n                balance[p.id] = gesamtSumme;\n            }\n        }\n        return {\n            bezahlungen: bezahlungen,\n            balance: balance\n        };\n    }\n\n    async calculateBalance(kontokorrentId: string) {\n        return (await this.getBalance({\n            kontokorrentId: kontokorrentId,\n            zwischengespeicherte: true,\n            bisLaufendeNummer: null\n        })).balance;\n    }\n}","import { Store } from \"../lib/Store\";\nimport { ApiClient } from \"../../api/ApiClient\";\nimport { Action } from \"../lib/Action\";\nimport { KontokorrentDatabase } from \"../../lib/KontokorrentDatabase\";\nimport { Bezahlung, BezahlungStatus } from \"../State\";\nimport { filterBezahlungen } from \"../../lib/filterBezahlungen\";\nimport { ActionNames } from \"./ActionNames\";\nimport { KontokorrentSynchronizer } from \"../../lib/KontokorrentSynchronizer\";\nimport { BalanceCalculator } from \"../../lib/BalanceCalculator\";\nimport { KontokorrentBalance } from \"../../lib/KontokorrentBalance\";\n\nexport class KontokorrentGeoeffnet implements Action {\n    readonly type = ActionNames.KontokorrentGeoeffnet;\n    constructor(public id: string) {\n\n    }\n}\n\nexport class KontokorrentBezahlungen implements Action {\n    readonly type = ActionNames.KontokorrentBezahlungen;\n    constructor(public kontokorrentId: string, public bezahlungen: Bezahlung[]) {\n\n    }\n}\n\nexport class KontokorrentSynchronisieren implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisieren;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentSynchronisiert implements Action {\n    readonly type = ActionNames.KontokorrentSynchronisiert;\n    constructor(public kontokorrentId: string) {\n\n    }\n}\n\nexport class KontokorrentBalanceAktualisiert implements Action {\n    readonly type = ActionNames.KontokorrentBalanceAktualisiert;\n    constructor(public kontokorrentId: string, public balance: KontokorrentBalance) {\n\n    }\n}\n\nexport type KontokorrentSyncActions =\n    | KontokorrentGeoeffnet\n    | KontokorrentBezahlungen\n    | KontokorrentSynchronisieren\n    | KontokorrentSynchronisiert\n    | KontokorrentBalanceAktualisiert;\n\nexport class KontokorrentSyncActionCreator {\n\n    constructor(private store: Store,\n        private apiClient: ApiClient,\n        private db: KontokorrentDatabase) {\n\n    }\n    private async refreshBezahlungen(id: string) {\n        let aktionen = filterBezahlungen(await this.db.getAktionen(id)).map(b => {\n            return {\n                ...b,\n                status: BezahlungStatus.Gespeichert\n            };\n        });\n        let zwischengespeicherte = (await this.db.getZwischengespeicherteBezahlungenForKontokorrent(id)).map(b => {\n            let x: Bezahlung = {\n                status: BezahlungStatus.Zwischengespeichert,\n                beschreibung: b.beschreibung,\n                bezahlendePersonId: b.bezahlendePersonId,\n                empfaengerIds: b.empfaengerIds,\n                id: b.id,\n                wert: b.wert,\n                zeitpunkt: b.zeitpunkt\n            };\n            return x;\n        }).filter(b => !aktionen.some(a => a.id == b.id));\n        this.store.dispatch(new KontokorrentBezahlungen(id, [...aktionen, ...zwischengespeicherte]));\n    }\n\n    private async calculateBalance(id: string) {\n        let balance = await (new BalanceCalculator(this.db).calculateBalance(id));;\n        this.store.dispatch(new KontokorrentBalanceAktualisiert(id, balance));\n    }\n\n    private async refreshKontokorrent(id: string) {\n        await Promise.all([this.refreshBezahlungen(id), this.calculateBalance(id)]);\n    }\n\n    private async kontokorrentSynchronisieren(id: string) {\n        this.store.dispatch(new KontokorrentSynchronisieren(id));\n        let laufendeNummer = await (new KontokorrentSynchronizer(this.db).getLaufendeNummer(id));\n        let res = await this.apiClient.getAktionen(id, laufendeNummer);\n        if (res.success) {\n            await this.db.addAktionen(id, res.aktionen);\n            if (res.aktionen.length > 0) {\n                await this.refreshKontokorrent(id);\n            }\n        }\n        this.store.dispatch(new KontokorrentSynchronisiert(id));\n    }\n\n\n\n    async kontokorrentOeffnen(oeffentlicherName: string) {\n        let kk = await this.db.getPerOeffentlichName(oeffentlicherName);\n        if (null != kk) {\n            this.store.dispatch(new KontokorrentGeoeffnet(kk.id));\n            await Promise.all([this.db.setZuletztGesehenerKontokorrentId(kk.id), this.refreshKontokorrent(kk.id)]);\n            await this.kontokorrentSynchronisieren(kk.id);\n        }\n    }\n}","import { ApiClient } from \"../api/ApiClient\";\nimport { AccountInfoStore } from \"../lib/AccountInfoStore\";\nimport { KontokorrentDatabase } from \"../lib/KontokorrentDatabase\";\nimport { BeschreibungVorschlagActionCreator } from \"../state/actions/BeschreibungVorschlagActionCreator\";\nimport { KontokorrentSyncActionCreator } from \"../state/actions/KontokorrentSyncActionCreator\";\nimport { Action } from \"../state/lib/Action\";\n\nlet storeAdapter = {\n    dispatch(action: Action): void {\n        self.postMessage({ type: \"statedispatch\", msg: action });\n    }\n}\n\nexport const enum WorkerMessageType {\n    KontokorrentOeffnen,\n    GetBeschreibungVorschlaege,\n    ResetBeschreibungenCache\n}\n\nexport interface KontokorrentOeffnenMessage {\n    type: WorkerMessageType.KontokorrentOeffnen;\n    oeffentlicherName: string;\n}\n\nexport interface GetBeschreibungVorschlaegeMessage {\n    type: WorkerMessageType.GetBeschreibungVorschlaege;\n    kontokorrentId: string;\n    eingabe: string;\n}\nexport interface ResetBeschreibungenCacheMessage {\n    type: WorkerMessageType.ResetBeschreibungenCache;\n}\n\ntype WorkerMessage = KontokorrentOeffnenMessage\n    | GetBeschreibungVorschlaegeMessage\n    | ResetBeschreibungenCacheMessage;\n\nconst db = new KontokorrentDatabase();\nconst accountInfoStore = new AccountInfoStore(db);\nconst apiClient = new ApiClient(accountInfoStore);\nconst beschreibungVorschlagActionCreator = new BeschreibungVorschlagActionCreator(db, storeAdapter);\nconst kontokorrentSyncActionCreator = new KontokorrentSyncActionCreator(storeAdapter, apiClient, db);\n\nasync function process(msg: WorkerMessage) {\n    switch (msg.type) {\n        case WorkerMessageType.KontokorrentOeffnen:\n            await kontokorrentSyncActionCreator.kontokorrentOeffnen(msg.oeffentlicherName);\n            break;\n        case WorkerMessageType.GetBeschreibungVorschlaege:\n            await beschreibungVorschlagActionCreator.getVorschlaege(msg.kontokorrentId, msg.eingabe);\n            break;\n        case WorkerMessageType.ResetBeschreibungenCache:\n            beschreibungVorschlagActionCreator.resetCache();\n            break;\n    }\n}\n\nself.addEventListener(\"message\", e => {\n    let msg: WorkerMessage = e.data;\n    process(msg).catch(err => console.error(err));\n});","export function sortByAlphabetically<T, P extends keyof T>(collection: T[], keySelector: (x: T) => string): T[] {\n    return collection.sort((a, b) => keySelector(a).toLowerCase().localeCompare(keySelector(b).toLowerCase()));\n}","import { AccountInfo } from \"./AccountInfo\";\nimport { KontokorrentDatabase } from \"./KontokorrentDatabase\";\n\nexport class AccountInfoStore {\n    constructor(private db: KontokorrentDatabase) {\n\n    }\n\n    async set(accountInfo: AccountInfo): Promise<void> {\n        await this.db.setAccountInfo(accountInfo);\n    }\n    async get(): Promise<AccountInfo> {\n        return await this.db.getAccountInfo();\n    }\n    async clear(): Promise<void> {\n        await this.db.clearAccountInfo();\n    }\n\n    async getAccessToken(tokenType: \"google\" | \"anonymous\"): Promise<{ timestamp: number, value: string }> {\n        return await this.db.getAccessToken(tokenType);\n    }\n\n    async updateAccessTokenIfNewer(tokenType: \"anonymous\" | \"google\", value: string, lastTimeStamp: number) {\n        return await this.db.updateAccessTokenIfNewer(tokenType, value, lastTimeStamp);\n    }\n}\n\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","var fails = require('../internals/fails');\nvar whitespaces = require('../internals/whitespaces');\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nmodule.exports = function (METHOD_NAME) {\n  return fails(function () {\n    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;\n  });\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar toString = require('../internals/to-string');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = toString(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","// a string of all valid unicode whitespaces\nmodule.exports = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n","'use strict';\nvar $ = require('../internals/export');\nvar $trim = require('../internals/string-trim').trim;\nvar forcedStringTrimMethod = require('../internals/string-trim-forced');\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [820], function() { return __webpack_require__(1712); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"\" + \"0cdd927a1d4532914d47\" + \".bundle.js\";\n};","// This function allow to reference all chunks\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/v2/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t837: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkontokorrent\"] = self[\"webpackChunkkontokorrent\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","AccountType","async","postJson","url","body","token","init","method","headers","JSON","stringify","fetch","TokenRenewFailedException","constructor","networkError","InteractionRequiredException","ApiException","API_URL","environment","NeueBezahlungFailedException","BezahlungBearbeitenFailedException","BezahlungLoeschenFailedException","baseUrl","KontokorrentsStore","AppStateStore","AktionenStore","NeueBezahlungenStore","BezahlungStatus","groupBy","list","key","map","Map","forEach","item","k","collection","get","push","set","BeschreibungsVorschlaege","kontokorrentId","vorschlaege","type","filterBezahlungen","aktionen","bezahlungenMap","ordered","sort","a","b","laufendeNummer","bearbeiteteBezahlungId","geloeschteBezahlungId","bezahlung","id","Object","values","KontokorrentSynchronizer","db","i","sorted","this","getAktionen","v","length","GeteilteZahlung","wert","empfaengerAnzahl","isEmpfaenger","BalanceCalculator","erweitern","summe","nenner","andere","c","n","request","bisLaufendeNummer","filter","bezahlungen","gespeicherte","zwischengespeicherte","getZwischengespeicherteBezahlungenForKontokorrent","kk","getKontokorrent","geteilteZahlungen","p","personen","e","empfaengerIds","bezahlendePersonId","balance","gruppen","alleNenner","Array","from","keys","gesamtNenner","reduce","gesamtSumme","g","getBalance","KontokorrentGeoeffnet","KontokorrentBezahlungen","KontokorrentSynchronisieren","KontokorrentSynchronisiert","KontokorrentBalanceAktualisiert","storeAdapter","dispatch","action","self","postMessage","msg","cb","upgrade","oldVersion","newVersion","createObjectStore","keyPath","createIndex","put","zuletztGesehenerKontokorrentId","accesstokens","accountinfo","objectStoreNames","contains","deleteObjectStore","close","withInitialized","getAll","keySelector","name","toLowerCase","localeCompare","mapped","unwrapped","Promise","resolve","reject","tx","transaction","onerror","err","console","error","oncomplete","objectStore","add","ev","log","preventDefault","stopPropagation","appState","kks","getKontokorrents","kontokorrents","existing","some","d","delete","newIds","ex","find","combined","oeffentlicherName","getFromIndex","getAllFromIndex","clear","tokenType","t","value","lastTimeStamp","durability","store","timestamp","done","accountInfo","bezahlungId","aktion","status","m","accountInfoStore","setAccountInfo","getAccountInfo","clearAccountInfo","getAccessToken","updateAccessTokenIfNewer","apiClient","secret","ok","success","res","getAuthHeader","json","einladungsCode","params","encodeURIComponent","exists","ab","query","notfound","mapAktionen","zeitpunkt","Date","info","Error","anonym","tokenResponse","tokenInfo","expires","parse","google","beschreibungVorschlagActionCreator","resetCache","formatSearchString","s","replace","sameChars","Math","min","beschreibungenCache","beschreibungen","eingabe","beschreibung","search","result","trim","entries","r","occurence","formatted","indexOf","score","slice","kontokorrentSyncActionCreator","Gespeichert","Zwischengespeichert","calculateBalance","all","refreshBezahlungen","getLaufendeNummer","addAktionen","refreshKontokorrent","getPerOeffentlichName","setZuletztGesehenerKontokorrentId","kontokorrentSynchronisieren","addEventListener","kontokorrentOeffnen","getVorschlaege","process","data","catch","internalObjectKeys","hiddenKeys","concat","exports","f","getOwnPropertyNames","O","fails","whitespaces","module","METHOD_NAME","requireObjectCoercible","toString","whitespace","ltrim","RegExp","rtrim","createMethod","TYPE","$this","string","start","end","$","$trim","target","proto","forced","forcedStringTrimMethod","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","x","__webpack_exports__","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","definition","o","defineProperty","enumerable","chunkId","promises","u","miniCssF","globalThis","Function","window","obj","prop","prototype","hasOwnProperty","call","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","then"],"sourceRoot":""}